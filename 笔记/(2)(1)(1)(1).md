# 一、Java基础

### 1.final关键字的作用

被final修饰的类不可以被继承，被final修饰的方法不可以被重写，被final修饰的变量不可以被改变，如果修饰引用，那么表示引用不可变，引用指向的内容可变，被final修饰的方法，JVM会尝试将其内联，以挺高运行效率，被final修饰的常量，在编译阶段会存入常量池中。

## 2.abstract class和 interface有什么区别

声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能再该类中实现该类的情况，不能创建abstract类的实例，然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。

接口（interface）是抽象类的变体。在接口中，所有的方法都是抽象的。多继承性可通过实现这样的接口而获得。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。

## 3.Java集合类：list、set、quequ(Q)、map、stack的特点与用法？

Map

Map是键值对，键Key是唯一不能重复的，一个键对应一个值，值可以重复。TreeMap可以保证顺序，HashMap不保证顺序，即为无序的，Map中可以将Key和Value单独抽取出来，其中KeySet（）方法可以将所有的keys抽取成一个Set，而Values（）方法可以将map中所有的values抽取成一个集合。

Set

不包含重复元素，set中最多包含一个null元素，只能用Iterator实现单项遍历，Set中没有同步方法。

List

有序的可重复集合，可以在任意位置增加删除元素，用Iterator实现单向遍历，也可用ListIterator实现双向遍历。

Queue

Queue遵从先进先出原则，使用时尽量避免add（）和remove（）方法，而是使用offer（）来添加元素，使用poll（）来移除元素，它的优点是可以通过返回值来判断是否成功，LinkedList实现了Queue接口，Queue通常不允许插入nill元素。

Stack

Stack遵从后进先出原则，Stack继承自Vector，它通过五个操作用类Vector进行扩展，允许将向量视为堆栈，它提供了通常的push和pop操作，以及取堆栈顶点的peek（）方法、测试堆栈是否为空的empty方法等。

用法

如果涉及堆栈，队列等操作，建议使用List。

对于快速插入和删除元素的，建议使用LinkedList。

如果需要快速随机访问元素的，建议使用ArrayList。

## 4.说出ArrayList，Vector，LinkedList的储存性能和特性

ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际储存的数据以便增加和插入元素，他们都允许直接按序号查询元素，但是插入元素要设计数组元素移动等内存操作，所以查询快，增删慢，Vector由于使用的synchronized方法，通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或者向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。

## 5.内存泄漏和内存溢出？

内存泄漏，是指应用程序在申请内存后，无法释放已经申请的内存空间，一次内存泄漏的危害可以忽略，但是如果任其发展最终会导致内存溢出。如读取文件后流要进行及时的关闭以及对数据库连接的释放。

内存溢出，是指应用程序在申请内存时，没有足够的空间供其使用。如我们在项目中对于大批量数据的导入，采用分批量提交的方式。

## 6.反射中，Class.forName()和ClassLoader.loadClass()的区别？

Class.froName(className) 方法，内部实际调用的方法是Class.forName(className,true,classloader);

第二个boolean参数表示是否需要初始化，Class.forName(className)默认也是需要初始化。

ClassLoader.loadClass(className) 方法，不进行初始化

## 7.Int和Integer的区别?

Integer是int的包装类型，在拆箱和装箱中，二者自动类型转换，int是基本数据类型，直接存数值。Integer是对象；用一个引用指向这个对象，由于Integer是一个对象，在JVM中对象需要一定的数据结构进行描述，相比int而言，其占用的内存更大一些。

## 8.String、StringBuilder、StringBuffer区别?

String     			字符串常量     不可变     使用字符串拼接时是不同的2个空间9

StringBuilder	字符串变量    	可变		线程不安全	字符串拼接直接在字符串后追加

StringBuffer 	字符串变量		可变			线程安全		字符串拼接直接在字符串后追加

1.StringBuilder执行效率高于Stringbuffer高于String

2.String是一个常量，是不可变的，所以对于每一次的+=赋值都会创建一个新的对象。

​	StringBuilder和StringBuffer都是可变的，当进行字符串拼接时采用append方法，在原来的基础上追加，所以性能比String要高，又因为StringBuffer是线程安全的，而StringBuilder是线程非安全的，所以StringBuilder的效率高于StringBuffer.

3.对于大数据量的字符串拼接，采用StringBuffer和StringBuilder

## 9.Hashtable和Hashmap的区别？

1.HashTable线程安全，HashMap非线程安全

2.Hashtable不允许null值（key和value都不可以），HashMap允许null值（key和value都可以）

3.两者的遍历方式大同小异，Hashtable仅仅比HashMap多一个elements方法

## 10.说几个常见的编译时异常?

SQLException  	提供有关数据库访问错误或其他错误的信息的异常。

IOexception		表示发生了某种I/O异常的信号。此类是由失败或者中单的I/O操作产生的一般异常类.

FileNotFoundException 	当试图打开指定路径名表示的文件失败时，抛出此异常

ClassNotFundException 	找不到指定名称的类的定义.

EOFEException  当输入过程中意外到达文件或者流的末尾时，抛出异常。

## 11.方法重载的规则？

方法名一致，方法参数的顺序，类型，个数不同。

重载与方法的返回值无关，存在于父类与子类之间。

## 12.方法重写的规则

方法名，返回值，参数的顺序、类型、个数相同，构造方法不能被重写，声明为final的方法不能被重写，声明为static的方法不存在重写;访问权想不能比父类更低，重写之后的方法不能抛出比父类更宽泛的异常；

### 13.throw和throws的区别

throw:

throw 语句是用在方法体内，表示抛出异常。throw是具体向外抛出异常的动作，所以它抛出的是一个异常实例，执行throw一定是抛出了某种异常。

throws

throws 语句是用在方法声明后面，表示如果抛出异常，由方法的调用者来进行异常的处理。throws 主要是声明这个方法会抛出某种类型的异常，让它的使用者知道需要捕获的异常的类型。throws表示出现异常的一种可能性，并不一定会发生这种异常.

## 14.抽象类和接口的区别？

1、接口中所有的方法隐含的都是抽象方法，而抽象类则可以同时包含抽象和非抽象的方法。

2、类可以实现很多个接口，但是只能继承一个抽象类

3、类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得生命成是抽象的。

4、抽象类在实现接口的情况下，可以不实现接口的方法。

5、Java 接口中声明的变量默认都是final的。抽象类可以包含非final的变量。

6、Java 接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected 或者是public

7、接口时绝对抽象的，不可以被实例化（java 8 已支持在接口中实现默认的方法）。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。

## 15.Java的基础类型和字节大小？

字节型  byte   8位； 	短整型  short  16位；   整形  int   32位；  长整型   long  64位；

布尔型   boolean  8位；  字符型   char  16位；  浮点型   float  325位；  双精度  double  64位；

## 16.四个访问修饰符访问级别？

public:用public修饰的类，方法和变量，整个项目都可以访问
protected：用protected修饰的类，方法和变量，包内的任何类以及包外继承了该类的子类均可访问
default：默认修饰符，只有包内的所有类才可以访问
private：用private修饰的类，方法和变量，只有本类可以访问



## 18.HashSet 的底层实现是什么?

HashSet 的实现是依赖于HashMap的，HashSet的值都是存储在HashMap中的。

在HashSet 的构造方法中会初始化一个 HashMap 对象，HashSet 不允许值重复。

因此，HashSet的值是作为HashMap的Key存储在HashMap中的，当存储的值已经存在时返回 false。

## 19.抽象类的意义？

抽象类的意义可以用三句话来概括：

1、为其他子类提供一个公共的类型

2、封装子类中重复定义的内容

3、定义抽象方法，子类虽然有不同的实现，但是定义时一致的

## 20.为什么重写equals时必须重写hashCode方法？

一般是用到HashMap，HashSet等集合的时候，需要重写equals和hashCode方法。

1、是为了提高效率，采取重写hashcode方法，先进行hashcode比较，如果不同，那么就没必要在进行equals的比较了，这样就大大减少了equals比较的次数 

2、两个对象，重写了其equals方法，假如equals方法返回为true，没重写hashcode方法，其返回的依然是两个对象的内存地址值，必然不相等。这就出现了equals方法相等，但是hashcode不相等的情况。这不符合hashcode的规则。如果需要将这些对象存储到集合中，比如hashSet、hashMap，这个时候就违背了原有集合的原则。

## 21.HashSet和TreeSet有什么区别？

hashSet 中元素是不可以重复的，无序的，可以为null值，但只能有一个null。内部的数据结构是哈希表，是线程不安全的。

treeSet  可以对元素进行排序，也是线程不安全的，

元素自身具备比较功能，即自然排序，需要实现Comparable接口，并覆盖其compareTo方法。

元素自身不具备比较功能，则需要实现Comparator接口，并覆盖其compare方法。

## 22.强引用和软引用和弱引用以及虚引用？

#### 1、强引用

最普遍的一种引用方式，只要强引用存在，则垃圾回收器就不会回收这个对象。

#### 2、软引用

用于描述还有用但非必须的对象，如果内存足够，不回收，如果内存不足，则回收。

#### 3、弱引用

弱引用和软引用大致相同，弱引用与软引用的区别在于：垃圾回收器扫描一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

#### 4、虚引用

虚引用主要用来跟踪对象被垃圾回收器回收的活动。跟其他引用的区别就是，虚引用必须和引用队列联合使用。

## 23、数组在内存中如何分配？

当一个对象使用 new 关键字创建的时候，会在堆上分配内存空间，然后才返回到对象的引用。这对数组来说也是一样，因为数组也是一个对象，简单的值类型的数组，每个数组成员是一个引用（指针），引用到栈上的空间。

## 24、Java中怎么创建一个不可变对象？

1.所有的成员变量必须是private修饰的

2.类和属性都用final修饰

3.不提供能够修改原有对象状态的方法，一般是不提供setter方法。

4.如果提供修改方法，需要新创建一个对象，并在新创建的对象上进行修改

5.通过构造器初始化所有成员变量，引用类型的成员变量必须进行深拷贝。

6.getter方法不能对外泄露this引用，以及成员变量的引用

## 25、Java中 ++  操作符是线程安全的吗？

不是线程安全的操作，它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。

## 26、new一个对象的过程和clone一个对象的过程？

new操作符的本意是分配内存。程序执行到new操作符时，首先去看new操作符后边的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫对象的初始化，构造方法返回后，一个对象创建完毕，可以把它的引用发布到外部，在外部就可以使用这个引用操纵这个对象。

clone在第一步是和new相似的，都是分配内存，调用clone 方法时，分配的内存和原对象相同，然后再使用原对象对应的各个域，填充新对象的域，填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。

## 27、Java 中==和 equals（）的区别？

==是比较内存地址。equals（）是对字符串的内容进行比较。

## 28、final、finalize 和 finally 的不同之处？

final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。

finally 是异常处理语句结构的一部分，表示总是执行。

finalize 是Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。

## 29、Java的多态表现在哪里？

多态要用动态绑定，否则就不是多态，方法重载也不是多态，当满足这三个条件：1、有继承 2、有重写 3、要有父类引用指向子类对象

## 30、静态类型有什么特点？

1、静态的属性：随着类的加载而加载，该属性不在属于某个对象，属于整个类

2、静态的方法：直接用类名调用，静态方法里不能访问非静态成员变量

3、静态代码块：随着类加载而执行，并且只执行一次

4、静态类：不能直接创建对象，不可被继承

## 31、Java创建对象的几种方式？

new 创建新对象；通过反射机制；采用clone机制；通过序列化机制；

## 32、Object中有哪些公共方法？

1、equals(obj);

比较其他对象是否“等于”此对象。

2、toString（）;

返回对象的字符串表示形式；

4、notify();

唤醒正在等待此对象监视器的单个线程。

5、notifyAll();

唤醒正在等待此对象监视器的所有线程。

6、hashCode();

返回对象的哈希码值。

7、clone();

实现对象的浅复制。

## 33、&和&&的区别

&&具有短路功能，即第一个表达式为false的时候，则不再运行第二个表达式。

## 34、在.java源文件中可以有多个类吗（内部类除外）？

一个.java源文件中可以包括多个类，但是单个文件只能中只能有一个public类，并且该public类必须与文件名相同

## 35、如何正确的退出多层嵌套循环？

使用循环标签和break退出

## 36、内部类有什么作用？

1、内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类

2、内部类的方法可以直接访问外部类的所有数据，包括私有的数据。

3、可以实现多重继承

4、可以避免修改接口而实现同一个类中两种同名方法的调用

## 37、深拷贝和浅拷贝的区别是什么？

深拷贝和浅拷贝最根本的区别在于是否真正的获取一个对象的复制实体，而不是引用

浅拷贝：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。

深拷贝：是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存。

## 38、String是基本数据类型吗？

string属于Java中的字符串类型，也是一个引用类型，并不属于基本的数据类型。

## 39、static的用法？

1、用来修饰成员变量，将其变为类的成员，从而实现所有对象能共享该成员变量，访问方式是：类名.静态成员名，对象也可以 . 静态成员变量，但是编译器不支持这样做，会给出警告。

2、用来修饰成员方法，将其变为类方法，可以直接使用类名.方法名调用

3、用来修饰代码块，在类加载的时候就会初始化，而且只初始化一次,有多个静态代码块的时候，会按照编写的顺序进行加载。

4、static虽然不能修饰普通类，但是可以用static关键字修饰内部类，使其变成静态内部类。

## 40、什么是值传递和引用传递？

对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。数据量非常大的话，运行效率会很低。

对象被引用传递，意味着传递的并不是实际的对象，而是直接把内存地址传过去了，也就是说操作的其实都是源数据，这样的话，修改的话就会影响源对象。

## 41、重载和重写的区别？

重载：方法名一致，方法参数的顺序，类型，个数不同。

重载与方法的返回值无关，存在于父类与子类之间，重载发生在编译时期。

重写：方法名，返回值，参数的顺序、类型、个数相同，构造方法不能被重写，声明为final的方法不能被重写，声明为static的方法不存在重写;访问权限不能比父类更低，重写之后的方法不能抛出比父类更宽泛的异常；

## 42、成员变量和局部变量的区别有哪些？

1、成员变量是属于类的，而局部变量是在方法中定义的变量或者是方法的参数；成员变量可以被修饰符所修饰，而局部变量不能被访问修饰符及static所修饰；成员变量和局部变量都能被final修饰；

2、成员变量在堆内存，局部变量存在于栈内存

3、成员变量是对象的一部分，它随着对象的创建而存在，而局部变量是随着方法的调用而自动消失；

4、成员变量有默认值；而局部变量没有。

## 43、静态方法和实例方法有何不同？

调用静态方法可以用 类名.方法名 和 对象名.方法名 ; 而调用实例方法只能用 对象名.方法名。

静态方法只能访问静态成员变量和静态方法，实例方法则无此限制；

## 44、什么是多态？

同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性；简单的说就是用父类引用指向子类对象。

## 45、多态的优点？

1、可扩充性。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性，继承性，以及其他特性的运行和操作。

2、可替换性。多态对已存在的代码具有可替换性；

3、灵活性和简洁性。

## 46、多态存在的三个必要条件？

要有继承。

要有方法的重写。

父类引用指向子类对象。

## 47、TreeMap、HashMap、LindedHashMap的区别?

LindedHashMap 可以保证HashMap集合有序。存入的顺序和取出的顺序一致。

TreeMap 实现SortMap接口，能够把他们保存的记录根据键排序，默认的是按键值的升序排序。当用Iterator遍历 TreeMap时，得到的记录是排过序的。

HashMap 是无序的，具有很快的访问速度。HashMap最多只允许一条记录为Null，HashMap不支持线程的同步，所以是线程不安全的。

## 48、Java面向对象的特征有哪些？

面向对象三大特征，封装，继承（extends），多态。抽象也算是体现出面向的特征。

## 49、列出一些常见的运行时异常？

ArithmeticException （算术异常）

ClassCastException (类转换异常)

illegalArgumentException (非法参数异常)

indexOutOfBoundsException (下标越界异常)

NullPointerException (空指针异常)

SecurityException (安全异常)

## 50、什么是反射？

反射就是动态加载对象，并对对象进行剖析。在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法，这种动态获取对象信息以及动态调用对象方法的功能就是java的反射机制。

## 51、反射的作用？

1、在运行时判断任意一个对象所属的类

2、在运行时构造任意一个类的对象

3、在运行时得到任意一个类所有的成员变量和方法

4、在运行时能够调用任意一个对象的方法

## 52、获取class的三种方式？

 对象调用 getClass（）方法来获取；类名.class 的方式得到；Class.forName（）获取。

## 53、break 和 continue的区别？

break用于完全结束一个循环，跳出循环体执行循环体之后的语句。

continue 用于跳过本次循环，继续下次循环。

## 54、运行时异常与一般异常有何异同？

运行时异常表示虚拟机操作中可能遇到的异常。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。

## 55、List、Map、Set三个接口存取元素时，，各有什么特点？

List 有序的，可以有重复元素。

Set 不能存放重复元素，无序的。

Map 保存键值对映射（kty--value），映射关系可以是一对一或多对一 。

## 56、Collection 和Collections的区别？

Collection 是集合类的上级接口，继承它的接口主要有List和 Set

Collections 是针对集合类的一个帮助类，它提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。

## 57、Error 和 Exception 有什么区别？

Exception 和Error 都是继承了Throwable类

error表示恢复不是不可能但是很困难 的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。

exception 是java程序运行中可预料的异常情况，可以获取到这种异常，并且进行相应的处理。

## 58、EJB的生命

### 

## 59、Comparable 和 Comparator接口的区别?

Comparable接口只包含一个compareTo（）方法。这个方法可以给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。Comparator接口包含compare() 和 equals() 两个方法。

## 60、switch能否作用在byte、long、string上？

switch可作用在char、byte、short、int和他们的包装类上。

switch不可作用于long、double、float、boolean，包括他们的包装类.

switch在java1.7以后才可以作用在String中，JDK1.5以后可以是枚举类型。

## 61、jdk中哪些类是不能继承的？

对于java中的类，如果是使用final修饰的话，那么这个类就不能够被继承，因为jdk的开发者认为，有一些最基本的类没要必要对开发者开放，如果用户

继承时操作有误，很可能引入很多问题。为了防止用户对基本类进行相应的扩展，也体现了java设计过程中的开闭原则，最终将这些类设计成为final的

java中常见的不能被继承的类有如下:

String,

StringBuffer,

StringBuilder,

基本类型的包装类如Double，Integer，Long

## 63、JDK和JRE的区别是什么？

java运行时环境（JRE）是讲要执行java程序的java虚拟机。它同时也包含了执行applet需要的浏览器插件。

java开发工具包（JDK）是完整的java软件开发包，包含了JRE，编译器和其他的工具，可以让开发者开发、编译、执行java应用程序

## 66、什么是迭代器（Iterator）？

Iterator接口提供了很多对于集合元素进行迭代的办法。每一个集合类都包含了可以返回迭代实例的迭代方法。

(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。
(2) 使用next()获得序列中的下一个元素。
(3) 使用hasNext()检查序列中是否还有元素。
(4) 使用remove()将迭代器新返回的元素删除。
Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。

## 67、Iterator 和 ListIterator的区别是什么？

Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List

Iterator对集合只能是前向遍历，ListIterator既可以向前遍历也可以向后遍历。

ListIterator实现Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引等等。

## 68、Enumeration 接口和 Iterator接口的区别有哪些？

Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能修改正在被iterator遍历的集合里边的对象。同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。

## 70、字符串常量池到底存在于内存空间的哪里？

JDK 6.0 字符串常量池在方法区，方法区的具体体现可以看做是堆中的永久区。

JDK 7.0 java 虚拟机规范中不再声明方法区，字符串常量池存放在堆空间中。

JDK 8.0 java 虚拟机规范中又声明了元空间，字符串常量池存放在元空间中。 

## 71、Java 中的编译器常量是什么？使用它又什么风险？

public static final 变量就是我们所属的编译期常量。

## 74.JDK1.8新特性

### 1、default关键字

 在接口中通过default修饰方法，可以在接口中定义具体的方法实现。

### 2、Lambda 表达式

大大简化代码的开发

### 3、函数式接口

函数式接口是指仅仅包含一个抽象方法的接口

### 4、Date Api更新　

时间类的更新

### 5、Stream API

充分利用现代多核CPU

## 75、ArrayList源码分析？

1、ArrayList是一种变长的集合类，基于定长数组实现，使用默认构造方法初始化出来的容量是10（1.7之后都是延迟初始化，就是第一次调用add方法添加元素的时候才将容量初始化为10）

2、ArrayList 允许空值和重复元素， 当往 ArrayList 中添加的元素数量大于其底层数组容量时，其会通过扩容机制重新生成一个更大的数组。ArrayList扩容的长度时原长度的1.5倍

3、由于ArrayList 底层基于数组实现，所以其可以保证在O(1) 时间复杂度下完成随机查找操作。

4、ArrayList 是非线程安全类，并发环境下，多个线程同时操作ArrayList，会引发不可预知的异常或错误。

5、顺序添加很方便

6、删除和插入需要复制数组，性能差

7、Integer.MAX_VALUE-8 :主要考虑到不同的 JVM ，有的 JVM 会在数组中保留了一些头信息，避免内存溢出，所以-8；

## 76、HashMap源码分析？

JDK1.7 数组+链表

JDK 1.8 数组+链表+红黑树（当链表长度到8时，转化为红黑树）

HashMap的扩容因子

默认0.75，也就是会浪费1/4的空间，达到扩容因子时，会将list扩容一倍，0.75是时间于空间的一个平衡值。

## 77、JDK8中的HashMap与JDK7的HashMap有什么不一样？

1. JDK8中新增了红黑树，JDK8是通过数组+链表+红黑树来实现的
2. JDK7中链表的插入是用的头插法，而JDK8中则改为了尾插法
3. JDK8中的因为使用了红黑树保证了插入和查询了效率，所以实际上JDK8中的Hash算法实现的复杂度降低了
4. JDK8中数组扩容的条件也发了变化，只会判断是否当前元素个数是否查过了阈值，而不再判断当前put进来的元素对应的数组下标位置是否有值。
5. JDK7中是先扩容再添加新元素，JDK8中是先添加新元素然后再扩容



## 78、HashMap中PUT方法的流程？

1. 通过key计算出一个hashcode
2. 通过hashcode与“与操作”计算出一个数组下标
3. 在把put进来的key,value封装为一个entry对象
4. 判断数组下标对应的位置，是不是空，如果是空则把entry直接存在该数组位置
5. 如果该下标对应的位置不为空，则需要把entry插入到链表中
6. 并且还需要判断该链表中是否存在相同的key，如果存在，则更新value
7. 如果是JDK7，则使用头插法
8. 如果是JDK8，则会遍历链表，并且在遍历链表的过程中，统计当前链表的元素个数，如果超过8个，则先把链表转变为红黑树，并且把元素插入到红黑树中

## 79、JDK8中链表转变为红黑树的条件？

1. 链表中的元素的个数为8个或超过8个
2. 同时，还要满足当前数组的长度大于或等于64才会把链表转变为红黑树。为什么？因为链表转变为红黑树的目的是为了解决链表过长，导致查询和插入效率慢的问题，而如果要解决这个问题，也可以通过数组扩容，把链表缩短也可以解决这个问题。所以在数组长度还不太长的情况，可以先通过数组扩容来解决链表过长的问题。

## 80、HashMap扩容流程是怎样的？

1. HashMap的扩容指的就是数组的扩容， 因为数组占用的是连续内存空间，所以数组的扩容其实只能新开一个新的数组，然后把老数组上的元素转移到新数组上来，这样才是数组的扩容

2. 在HashMap中也是一样，先新建一个2被数组大小的数组

3. 然后遍历老数组上的没一个位置，如果这个位置上是一个链表，就把这个链表上的元素转移到新数组上去

4. 在这个过程中就需要遍历链表，当然jdk7，和jdk8在这个实现时是有不一样的，jdk7就是简单的遍历链表上的没一个元素，然后按每个元素的hashcode结合新数组的长度重新计算得出一个下标，而重新得到的这个数组下标很可能和之前的数组下标是不一样的，这样子就达到了一种效果，就是扩容之后，某个链表会变短，这也就达到了扩容的目的，缩短链表长度，提高了查询效率

5. 而在jdk8中，因为涉及到红黑树，这个其实比较复杂，jdk8中其实还会用到一个双向链表来维护红黑树中的元素，所以jdk8中在转移某个位置上的元素时，会去判断如果这个位置是一个红黑树，那么会遍历该位置的双向链表，遍历双向链表统计哪些元素在扩容完之后还是原位置，哪些元素在扩容之后在新位置，这样遍历完双向链表后，就会得到两个子链表，一个放在原下标位置，一个放在新下标位置，如果原下标位置或新下标位置没有元素，则红黑树不用拆分，否则判断这两个子链表的长度，如果超过八，则转成红黑树放到对应的位置，否则把单向链表放到对应的位置。

6. 元素转移完了之后，在把新数组对象赋值给HashMap的table属性，老数组会被回收到。

   ## 90、为什么HashMap的数组的大小是2的幂次方数？

   JDK7的HashMap是数组+链表实现的

   JDK8的HashMap是数组+链表+红黑树实现的

   当某个key-value对需要存储到数组中时，需要先生成一个数组下标index，并且这个index不能越界。

   在HashMap中，先得到key的hashcode，hashcode是一个数字，然后通过 hashcode & (table.length - 1) 运算得到一个数组下标index，是通过与运算计算出来一个数组下标的，而不是通过取余，与运算相比于取余运算速度更快，但是也有一个前提条件，就是数组的长度得是一个2的幂次方数。

## 91、ConcurrentHashMap 源码分析？

ConcurrentHashMap是HashMap的升级版，HashMap是线程不安全的，而ConcurrentHashMap是线程安全。而其他功能和实现原理和HashMap类似。

## 92、JDK8的ConcurrentHashMap和JDK7的ConcurrentHashMap有什么区别？



1. JDK8中新增了红黑树
2. JDK7中使用的是头插法，JDK8中使用的是尾插法
3. JDK7中使用了分段锁，而JDK8中没有使用分段锁了
4. JDK7中使用了ReentrantLock，JDK8中没有使用ReentrantLock了，而使用了Synchronized
5. JDK7中的扩容是每个Segment内部进行扩容，不会影响其他Segment，而JDK8中的扩容和HashMap的扩容类似，只不过支持了多线程扩容，并且保证了线程安全

## JDK8中的ConcurrentHashMap为什么使用synchronized来进行加锁？



JDK8中使用synchronized加锁时，是对链表头结点和红黑树根结点来加锁的，而ConcurrentHashMap会保证，数组中某个位置的元素一定是链表的头结点或红黑树的根结点，所以JDK8中的ConcurrentHashMap在对某个桶进行并发安全控制时，只需要使用synchronized对当前那个位置的数组上的元素进行加锁即可，对于每个桶，只有获取到了第一个元素上的锁，才能操作这个桶，不管这个桶是一个链表还是红黑树。



想比于JDK7中使用ReentrantLock来加锁，因为JDK7中使用了分段锁，所以对于一个ConcurrentHashMap对象而言，分了几段就得有几个ReentrantLock对象，表示得有对应的几把锁。



而JDK8中使用synchronized关键字来加锁就会更节省内存，并且jdk也已经对synchronized的底层工作机制进行了优化，效率更好。

## DK8中的ConcurrentHashMap是如何扩容的？



首先，JDK8中是支持多线程扩容的，JDK8中的ConcurrentHashMap不再是分段，或者可以理解为每个桶为一段，在需要扩容时，首先会生成一个双倍大小的数组，生成完数组后，线程就会开始转移元素，在扩容的过程中，如果有其他线程在put，那么这个put线程会帮助去进行元素的转移，虽然叫转移，但是其实是基于原数组上的Node信息去生成一个新的Node的，也就是原数组上的Node不会消失，因为在扩容的过程中，如果有其他线程在get也是可以的。

# 二、Java IO、网络

## 1、BIO 和 NIO 和 AIO 的区别以及应用场景？

同步：java自己去处理io

异步：java将 io交给操作系统去处理，告诉缓存区大小，处理完成回调。

阻塞：使用阻塞 IO 时，java调用回一直阻塞到读写完成才返回。

非阻塞：使用阻塞IO时，如果不能立马读写，java调用会马上返回，当IO事件分发器通知可读写时在进行读写，不断循环直到读写完成。

**BIO** ： 同步阻塞IO模式，在 JDK1.4 出来之前，我们建立网络连接的时候采用 BIO 模式，需要先在服务端启动一个 ServerSocket，然后在客户端启动 Socket 来对服务端进行通信，默认情况下服务端需要对每 个请求建立一堆线程等待请求，而客户端发送请求后，先咨询服务端是否有线程相应，如果 没有则会一直等待或者遭到拒绝请求，如果有的话，客户端会线程会等待请求结束后才继续 执行；

服务器的实现模式是一个连接一个线程，这样的模式很明显的一个缺陷是，由于客户端连接数与服务器线程数成正比关系，可能造成不必要的线程开销，严重的还将导致服务器内存泄漏。

**NIO** : 	**同步非阻塞的IO模型**，在java1.4中引入了 NIO 。而服务器的实现模式是多个请求一个线程，即请求会注册到多路复用器 Selector 上，多路复用器轮询到连接有 IO 请求时才启动的一个线程处理。 NIO采⽤了双向通道进⾏数据传输，在通道上我们可以注册我们感兴趣的事件：连接事件、读写事件；NIO主要有三⼤核⼼部分：Channel(通道)，Buffer(缓冲区), Selector。传统IO基于字节流和字符流进⾏操作，⽽NIO基于 Channel 和Buffer(缓冲区)进⾏操作，数据总是从通道读取到缓冲区中，或者从缓冲区写⼊到通道中。

Selector(选择区)⽤于监听多个通道的事件（⽐如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。

**AIO** :  **异步非阻塞IO模型**，JDK1.7 发布了NIO2.0,也就是AIO，这是真正意义上的异步非阻塞，服务器的实现模式为多个有效请求一个线程，客户端的 IO 请求都是由 OS 先完成再通知服务器应用去启动线程处理。

应用场景：并发连接数不多时采用BIO，因为它编程和调试都非常简单，但如果涉及到高并发的情况，应选择NIO 或 AIO，更好的建议是采用成熟的网络通信框架 Netty。

## 12. rpc和http的区别，使⽤场景？

#### **a. 区别：**

**传输协议**

RPC，可以基于TCP协议，也可以基于HTTP协议HTTP，基于HTTP协议

**传输效率**

RPC，使⽤⾃定义的TCP协议，可以让请求报⽂体积更⼩，或者使⽤HTTP2协议，也可以很好的减少报⽂

的体积，提⾼传输效率

HTTP，如果是基于HTTP1.1的协议，请求中会包含很多⽆⽤的内容，如果是基于HTTP2.0，那么简单的封

装以下是可以作为⼀个RPC来使⽤的，这时标准RPC框架更多的是服务治理

**性能消耗，主要在于序列化和反序列化的耗时**

RPC，可以基于thrift实现⾼效的⼆进制传输

HTTP，⼤部分是通过json来实现的，字节⼤⼩和序列化耗时都⽐thrift要更消耗性能

**负载均衡**

RPC，基本都⾃带了负载均衡策略

HTTP，需要配置Nginx来实现

**服务治理**（下游服务新增，重启，下线时如何不影响上游调⽤者）

RPC，能做到⾃动通知，不影响上游

HTTP，需要事先通知，修改Nginx配置

#### **b.** 总结：

RPC主要⽤于公司内部的服务调⽤，性能消耗低，传输效率⾼，服务治理⽅便。HTTP主要⽤于对外的异构环境，浏览器接⼝调⽤，APP接⼝调⽤，第三⽅接⼝调⽤等。

# 三、Java Web

## 1、session 和 cookie的区别？

session 是存储在服务器端，cookie是存储在客户端的，所以安全来讲 session 的安全性要比cookie高，然后我们获取sesiion里的信息是通过存放在会话cookie里的sessionid获取的。又由于session是存放在服务器的内存中，所以session里的东西不断增加会造成服务器的负担，所以会把很重要的信息存储在session中，而把一些次要东西存储在客户端的cookie里。然后cookie确切的说分为两大类，分为会话cookie和持久化cookie，会话cookie确切的说是，存放在客户端浏览器的内存中，所以说他的生命周期和浏览器是一致的，浏览器关了会话cookie也就消失了，然后持久化cookie是存放在客户端硬盘中，而持久化cookie的生命周期就是我们在设置cookie的时候设置的那个保存时间，然后我们考虑一问题，当浏览器关闭时，session会不会丢失，从上面叙述分析session的信息时通过会话cookie的sessionid获取的，当浏览器关闭的时候会话cookie消失，所以我们sessionid也就消失了，但是session的信息还存在服务器端，这时我们只是差不多所谓的session 但它并不是不存在。那么，session在什么情况下丢失，就是在服务器关闭的时候，或者session过期（默认时间是30分钟），再或者调用了invalidate（）方法。然后session在什么时候被创建呢，确切的说是通过调用 getsession() 来创建，这就是session与cookie的区别。

## 2、session 和 cookie联系？

session 是通过cookie来工作的 session 和 cookie是通过sessionid来联系的，通过sessionid我们可以获取到其他的信息。

## 3、servlet 的生命周期？

Servlet 生命周期可以分成四个阶段：加载和实例化、初始化、服务、销毁。

​     当客户第一次请求时，首先判断是否存在Servlet对象，若不存在，则有Web容器创建对象，而后调用init（）方法对其初始化，此初始化方法在整个Servlet生命周期中只调用一次。

​	完成Servlet对象的创建和实例化之后，Web容器会调用Servlet对象service（）方法来处理请求。

​	当Web容器关闭或者Servlet对象要从容器中被删除时，会自动调用destory（）方法。

## 4、转发（forward）和重定向（redirect）的区别？

1、从地址栏显示来说

转发（forward） 是服务器直接访问目标地址的URL，然后再把这些内容发送给浏览器，所以URL不变。

重定向（redirect） 是服务器根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址，所以地址栏显示的是新的URL

2、从数据共享来说

转发（forward）：转发页面和转发到的页面可以共享 request 里边的数据。

重定向（redirect）: 不能共享数据

3、从运用地方来说

转发（forward）：一般用于用户登录的时候，格局角色转发到相应的模块。

重定向（redirect）: 一般用户用户注销登录时返回主页面和跳转到其他的网站等

4、从效率来说

转发：高

重定向：低

## 5、tomcat容器是如何创建servlet类实例？用到了什么原理？

当容器启动时，会读取在webapps 目录下所有的 web 应用中的 web。xml文件，然后对 xml 文件进行解析， 并读取 servlet 注册信息。然后，将每个应用中注册的 servlet 类都进行加载，并通过反射的方式实例化。

## 6、JDBC访问数据库的基本步骤是什么？

第一步：Class.forName()加载数据库连接驱动；

第二步：DriverManager.getConnection() 驱动管理获取数据连接对象

第三步：根据SQL获取sql会话对象，有2种方式 Statement、PrepareStatement;

第四步：执行SQL，执行SQL前如果有参数值就设置参数值 setXXX（）；

第五步：处理结果集；

第六步:关闭结果集，关闭会话，关闭连接。

## 7、数据库连接池的原理，为什么要使用连接池？

1、数据库连接是一件费时的操作，连接池可以使多个操作共享一个连接。

2、数据库连接池的基本思想就是为数据库建立一个”缓冲池“。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从”缓冲池“中取一个，使用完毕之后再放回去。我们可以通过设定连接池最大连接数来防止系统无尽的与数据库连接。更为重要的是我们可以通过连接池的管理机制监视数据库的连接的数量，使用情况，为系统开发，测试及性能调整提供依据。

3、使用连接池是为了提高对数据库连接资源的管理



## 8、JSP的四大范围

JSP中的四种作用域包括，page、request、session 和 application

## 9、request作用?

1、获取请求参数 getParameter()

2、获取当前Web应用的虚拟路径 getContextPath

3、转发 getRequestDispatcher(路径).forward(request,response)

4、它还是一个域对象





# 四、开源框架

# Spring

## 1、重要的Spring模块？

Spring Core：基础，可以说Spring其他所有的功能都依赖于该类库。主要提供IOC和DI功能。

Spring Aspects：该模块为与AspectJ的集成提供支持。

Spring AOP：提供面向方面的编程实现。

Spring JDBC：Java数据库连接。

Spring JMS：Java消息服务。

Spring ORM：用于支持Hibernate等ORM工具。

Spring Web：为创建Web应用程序提供支持。

Spring Test：提供了对JUnit和TestNG测试的支持。

## 1.Spring中的IOC

1. 控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。

通常A依赖B时，我们会在A中new个B，依赖实现的过程由我们自己控制，引入Spring的IOC容器后，我们把对象的依赖关系交给Spring容器去管理，我们只需要在类A中声明一下依赖关系就行。容器会自动创建我们需要的依赖对象，并注入。我们由主动控制，变为被动注入，这就是控制反转。

Spring IOC容器设计，主要是基于BeanFactory和ApplicationContexe接口，而ApplicationContext是BeanFactory子接口，ApplicationContext是在BeanFactory基础上进行了完整其他功能

## 2、Spring 常用的注入方式有哪些？

**构造器依赖注入**：构造器依赖注入通过容器触发一个类的构造器来实现的

**Setter方法注入**：Setter 方法注入是容器通过调用无参构造器或无参静态工厂方法实现

**基于注解的注入**

## 2、AOP

面向切面编程，传统的OOP不是从上到下的一种逻辑关系吗，AOP采用的是一种横切的技术，将我们封住好的对象切开，然后把我们的代码放进去，这些代码一般是一些重复出现的与业务没有关系的代码，比如事务处理，日志记录，权限拦截，动态织入业务代码中。这样就实现降低耦合的效果。

1. 切面（Aspect）：官方的抽象定义为“一个关注点的模块化，这个关注点可能会横切多个对象”。
2. 连接点（Joinpoint）：程序执行过程中的某一行为。
3. 通知（Advice）：“切面”对于某个“连接点”所产生的动作。
4. 切入点（Pointcut）：在 AOP 中通知和一个切入点表达式关联。
5. 目标对象（Target Object）：被一个或者多个切面所通知的对象。
6. AOP 代理（AOP Proxy）：在 Spring AOP 中有两种代理方式，JDK 动态代理和 CGLIB 代理。

## 3、循环依赖

Spring是能够解决set属性赋值的循环依赖，但是构造器注入的是会有问题的，构造器在实例化的时候会出现死结，而set可以预先实例化后赋值所以好解决。

- **一级缓存**  : 用于保存实例化、注入、初始化完成的bean实例。

​     这里就是生命周期已经加载完成了的对象

- **二级缓存** : 用于保存实例化完成的bean实例.

其实也就是new完了的对象，但是没有进行set（依赖注入）、以及初始化的对象，就是简单的实例化对象。

- **三级缓存**  : 用于保存bean创建`ObjectFactory`工厂，方便后续可以创建代理对象。

这个工厂里面会包含bean的创建，可能是普通对象，可能是代理过后的对象。可以理解为先把new完之后的**实例引用**先获取到。



三级缓存里面查找，这时候已经能够找到了，就会从`ObjectFactory`工厂中返回一个对象，**这个对象可能是普通实例也可能是代理对象。** 这个时候会加入到二级缓存中，下一次查找就能从一级，然后到二级直接找到对象了，不会在走到三级封装成`ObjectFactory`对象了；

**也就是说，发生循环的时候，会从工厂中将对象提前实例化出来，然后这个引用会被会注入到发生循环依赖的Bean作为属性填充。**

## 3、Bean的生命周期

实例化->属性赋值->初始化->销毁

**实例化**

  1、Spring 容器根据配置中的 beanDefinition（得非内肾）定义中实例化 bean。

**属性赋值**

  2、Spring 使用依赖注入（构造器或者 setter）填充所有属性，如 bean 中所定义的配置。

**初始化之前**

  3、如果 bean 实现 BeanNameAware 接口，Spring 将 Bean 的 ID 传递给setBeanName()方法

  4、如果 bean 实现 BeanFactoryAware 接口，Spring 将调用 setBeanFactory() 方法，将 BeanFactory 容器实例传入；

  5、如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。

  6、如果Bean实现了BeanPostProcessor（普若塞死）接口，Spring就将调用他们的postProcessBefore Initialization(恩内受了Z肾)方法。

**初始化**

  7、如果Bean 实现了（恩内受来zing）InitializingBean接口，Spring将调用他们的after（破破忒死）Properties Set()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用

**初始化之后**

  8、最后，如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的post Process After Initialization(恩内受了Z肾)方法。

  9、此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。

**销毁**

  10、如果 bean 实现 （dei死抛死bo）DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。如果为 bean 指定了 destroy 方法（ 的 destroy-method 属性），那么将调用它。

## 4、Bean 的作用域?

1. singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的；
2. prototype : 每次请求都会创建一个新的 bean 实例；
3. request：每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效；
4. session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效；
5. global-session：spring5已经没有了

## 5、Spring事务管理的方式有几种？

1.编程式事务：在代码中硬编码（不推荐使用）。

2.声明式事务：在配置文件中配置（推荐使用），分为基于XML的声明式事务和基于注解的声明式事务（@Transaction）

## 5、Spring的事务特性

**原子性**：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；

**一致性**：执行事务前后，数据保持一致；

**隔离性**：并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的；

**持久性**: 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

## 6、事务的隔离级别

- READ UNCOMMITTED（**读未提交数据**）：允许事务读取未被其他事务提交的变更数据，会出现脏读、不可重复读和幻读问题。
- READ COMMITTED（**读已提交数据**）：只允许事务读取已经被其他事务提交的变更数据，可避免脏读，仍会出现不可重复读和幻读问题。
- REPEATABLE READ（**可重复读**）：确保事务可以多次从一个字段中读取相同的值，在此事务持续期间，禁止其他事务对此字段的更新，可以避免脏读和不可重复读，仍会出现幻读问题。
- SERIALIZABLE（**序列化**）：确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作，可避免所有并发问题，但性能非常低。



## 5、事务产生的问题

##### 脏读：

打算提交但是数据回滚了，读取了提交的数据

##### 不可重复读：

读取了修改前的数据

##### 幻读：

读取了插入前的数据

## 6、事务的传播行为

##### REQUIRED： 瑞快儿得

表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务

##### SUPPORTS：死破儿斯

表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行

##### MANDATORY：满得锤

表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常

##### REQUIRED_NEW：瑞快儿得 牛

表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。

##### NOT_SUPPORTED：死破儿得

表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。

##### NEVER：乃沃儿

表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常

**NESTED**：表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行



## 7、Spring 框架中用到了哪些设计模式？

1. 工厂设计模式 : Spring 使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象；
2. 代理设计模式 : Spring AOP 功能的实现；
3. 单例设计模式 : Spring 中的 Bean 默认都是单例的；
4. 模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 这些以 Template 结尾的类，它们就使用到了模板模式；
5. 包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源；
6. 观察者模式：Spring 事件驱动模型就是观察者模式很经典的一个应用；
7. 适配器模式：Spring AOP 的增强或通知(Advice)使用到了适配器模式、SpringMVC 中也是用到了适配器模式适配 Controller。



## 8、ApplicationContext 通常的实现有哪些?

1. FileSystemXmlApplicationContext：此容器从一个 XML 文件中加载beans 的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。
2. ClassPathXmlApplicationContext：此容器也从一个 XML 文件中加载beans 的定义，这里，你需要正确设置 classpath 因为这个容器将在 classpath 里找 bean 配置。
3. WebXmlApplicationContext：此容器加载一个 XML 文件，此文件定义了一个 Web 应用的所有 bean。

## 9、BeanFactory和ApplicationContext的区别

**BeanFactory：**

是Spring里面最低层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能；



**ApplicationContext：**

应用上下文，继承BeanFactory接口，它是Spring的一个更高级的容器，提供了更多的有用的功能；

1) 国际化（MessageSource）

2) 访问资源，如URL和文件（ResourceLoader）

3) 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层  

4) 消息发送、响应机制（ApplicationEventPublisher）

5) AOP（拦截器）

# Spring MVC

## 1、SpringMVC的工作流程？

1、用户发送请求到前端控制器(**DispatcherServlet**)

2、前端控制器收到请求调用处理映射器(**HandlerMapping**)

3、处理映射器根据请求url找到具体的处理器(**Handler**)，生成处理器对象及处理器拦截器，一并返回给前端控制器

4、前端控制器再通过处理器适配器( **HandlerAdapter**)调用处理器

5、执行处理器

6、controller 执行完返回 ModelAndView

7、处理器适配器将controller执行结果 ModelAndView返回给前端控制器

8、前端控制器将ModelAndView 传给视图解析器

9、视图解析器(**View resolver**)解析后返回具体的view

10、前端控制器对view进行渲染视图

11、前端控制器将渲染结果返回给客户端。



# Mybatis

## 1、Mybatis和Hibernate和SpringData JPA的区别

Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装。属于全自动的ORM框架，着力点在于实体类和数据库表之间的映射，完成映射即可自动生成和执行sql。

SpringData JPA：Spring Data是一个通过命名规范简化数据库访问，其主要目标是使得对数据的访问变得方便快捷，继承基础接口,可使用内置的增删改查方法。支持这套规范的框架是hibernate，因此底层框架还是hibernate。

Mybatis：属于半自动的ORM框架，着力点在于实体类和SQL之间的映射，自己编写sql语句，主要依赖于SQL的编写与ResultMap的映射。然后通过配置文件将所需的参数和返回的字段映射到POJO。

## 2、Mybatis的一级缓存和二级缓存？

一级缓存：基于Cache接口的实现类 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 SqlSession，当 SqlSession flush (刷新) 或 close(关闭) 之后，该 SqlSession 中的所有 Cache 就将清空，默认打开一级缓存；

二级缓存：与一级缓存其机制相同，默认也是采用 Cache接口的实现类PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace 命名空间)。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口，可在它的Mapper映射文件中配置 ；

对于缓存数据更新机制，当某一个作用域的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。

二级缓存的缺点：不同的 Mapper 文件 操作了同一个表，就会造成缓存数据不一致的情况；

## 3、mybatis动态sql

1. MyBatis 动态 SQL 可以让我们在 XML 映射文件内，以标签的形式编写动态 SQL，完成逻辑判断和动态拼接 SQL 的功能；
2. MyBatis 提供了 9 种动态 SQL 标签：trim、where、set、foreach、if、choose、when、otherwise、bind；
3. 执行原理：从 SQL 参数对象中计算表达式的值，根据表达式的值动态拼接 SQL，以此来完成动态 SQL 的功能。

# Spring boot

## 1、Spring boot 自动装配原理

Springboot的启动是依靠main方法的启动，在main方法中有springapplication.run()方法，在run方法中有一个（refreshcontext）刷新容器的方法，再刷新容器的时候，他会通过解析注解 解析配置文件的方式把我们的bean注入到容器里面，这是就会解析到我们的springbootapplication注解，里面有一个EnableAutoConfiguration的注解，在这个注解里里有一个核心注解@import他会导入一个AutoConfiguration Import Selector类，在这个类中里面有一个select Imports()方法，利用 SpringFactoriesLoader类 把文件META-INF/spring.factories（法克特瑞死）中一个key为EnableAutoconfiguration下的所有的类获取到， 将所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容器中。启动SpringBoot时，会加载这些自动装配类，这些自动装配类有元注解（ConditionalOnXxx）判断是否自动装配，如果判断确定自动装配，会加载相关的Properties；

**所以spring boot在整个的启动过程中，其实就是在类路径的META-INF/spring.factories 文件中找到EnableAutoConfiguration对应的所有的自动配置类，然后将所有自动配置类加载到spring容器中。**

## 2、Spring Boot 的核心注解是哪个？

@SpringBootApplication，主要组合包含了以下 3 个注解：

**@SpringBootConfiguration**：组合了 @Configuration 注解，实现配置文件的功能。

**@EnableAutoConfiguration**：打开自动配置的功能，也可以关闭某个自动配置的选项。。如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。

**@ComponentScan**：Spring组件扫描。

# 五、JVM  

## 1、Java 虚拟机的内存划分？

##### 一、程序计数器

线程私有的，是一块较小的内存空间，每个线程都有它自己的程序计数器，并且任何时间一个线程只有一个方法在执行，也就是所谓的当前方法。可以看做当前线程所执行的字节码的行号指示器，程序计数器会存储当前线程正在执行的 java 方法的 Jvm 指令地址。

##### 二、Java 虚拟机栈

每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧，对应着一次次的java方法调用，前面谈程序计数器时，提到的当前方法；同理，在一个时间点，对应的只有一个活动的栈帧，通常叫做当前帧，方法所在的类叫做当前类。如果在该方法中调用了其他方法，对应的新的栈帧就会被创建出来，成为新的当前帧，一直到它返回结果或者执行结束。JVM直接对栈的操作只有两个，就是对栈帧的压栈和出栈。

栈帧中存储着局部变量表，操作栈，动态链接，方法出口。

##### 第三、本地方法栈

也是线程私有的，它和Java虚拟机栈是非常的相似的，不同的是，本地方法栈服务的对象是native原生方法，而虚拟机栈服务的是java方法。在 Hotspot JVM 中，选择合并了虚拟机栈和本地方法栈。

##### 第四、堆

堆被所有的线程共享，它是Java内存管理的核心区域，用来放置 Java 对象实例。创建的对象和数组都保存在堆内存中，也是垃圾收集器进行垃圾收集的最重要的区域。由于现代JVM 采用分代收集算法，因此 Java堆从GC的角度还可以细分为：新生代（Eden区、From survivor 区 和 To Survivor区）和老年代。

##### 第五、方法区

就是我们常说的永久代，线程共享的。用于存储被JVM加载的类的信息、常量、静态变量、即时编译器编译后的代码等数据。Java 8中 永久代就被移出 Hotspot JVM了，移除永久代可以促进 HotsSpot与JRockit 的融合，因为JRockit没有永久代。元空间取代了永久代，元空间的是在内存中的。

运行时常量池。这是方法去的一部分。Class文件除了有类的版本、字段、方法、接口等信息外，还有一项信息是常量池。Java的常量池可以存放各种常量信息，不管是编译去生成的各种字面量，还是需要在运行时决定的符号引用，这部分内容将在类加载后存放到常量池中。

## 2、什么是Java虚拟机？为什么Java被称作是无关平台的编程语言？

Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Javau虚拟机执行的字节码文件。

Java被设计成允许应用程序可以运行的任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译，Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。

## 3、如何判断一个对象应该被回收？

##### 一、引用计数算法：

判断对象的引用数量：

​		通过判断对象的引用数量来决定对象是否可以被回收；

​		每个对象实例都有一个引用计数器，被引用则+1，完成引用则 -1；

​		任何引用计数为 0 的对象实例可以被当作垃圾收集；

优缺点：

​		优点：执行效率高，程序执行受影响较小；

​		缺点：无法检测出循环引用的情况，导致内存泄漏；如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为 0。

##### 二、可达性分析算法：

​	通过判断对象的引用链是否可达来决定对象是否可以被回收；

​	可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点 GC ROOT 开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。不过要注意的是被判定为不可达对象不一定就会成为可回收对象。被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标记过程中仍然没有逃脱成为可回收对象的可能性，基本上就真的成为可回收对象了。

可以作为GC Roots的对象有：

​	虚拟机栈中引用的对象（栈帧中的本地变量表）；  
方法区中类静态属性引用的对象；  
方法区中常量引用的对象；  
本地方法栈中 JNI（Native方法）引用的对象。

## 4、GC 触发的条件？

1、程序调用System.gc 时可以触发；

2、系统自身来决定GC触发的时机；

## 5、可以作为 GCRoots 的对象有哪些？

虚拟机中引用的对象、

方法区中常量引用的对象、

方法区中类静态属性引用对象、

本地方法栈中JNI的引用对象

活跃线程中的引用对象

## 6、JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代？

Java堆 = 老年代 + 新生代 

新生代 = Eden + S0 + S1  （S0、S1也称from和to）

当Eden区的空间满了，Java虚拟机会触发一次  Minor GC ，以收集新生代的垃圾，存活下来的对象则会转移到Survivor区。

大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年代；

如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次 Minor  GC，年龄+1，熬过了一轮又一轮，若年龄超过一定限制（15），则被晋升到老年代。即长期存活的对象进入老年代。

Minor  GC是清理新生代

Full  GC老年代满了而无法容纳更多的对象，Minor  GC 之后通常就会进行 Full  GC ，Full  GC清理整个内存堆（包括新生代和老年代）

Major GC 发生在老年代的GC，清理老年区，经常会伴随至少一次Mino  GC，比Minor  GC慢10倍以上。



## 7、Minor  GC， Full  GC 触发条件？

##### Minor  GC触发条件：

当Eden区满时，触发Minor  GC。

##### Full  GC触发条件：

(1) 调用System.gc时，系统建议执行Full  GC，但是不必然执行

(2) 老年代空间不足

(3) 方法区空间不足

(4) 通过Minor  GC 后进入老年代的平均大小大于老年代的可用内存

(5) 由Eden区、From Space区向 To Space区复制时，对象大小大于 To Space可存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。

## 8、导致Full  GC一般有哪些情况？

（1）老年代空间不足

（2）新生代设置过小

​			一是新生代GC次数非常频繁，增大系统消耗；

​			二是导致大对象直接进入老年代，占据了老年代剩余空间，诱发Full  GC

（3）新生代设置过大

​			一是新生代设置过大会导致老年代过小，从而诱发Full  GC；

​			二是新生代GC耗时大幅度增加

（4）Survivor（幸存区）设置过小

​			导致对象从eden直接到达老年代

（5）Survivor设置过大

​			导致eden过小，增加了GC频率

​			一般说来新生代占整个堆1/3比较合适

​	GC策略的设置方式

（1）吞吐量优先（可由XX：GCTimeRatio=n 来设置）

（2）暂停时间优先  （可由XX：MaxGCPauseRatio=n来设置）

## 9、双亲委派模型？

如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时，子加载器才会尝试自己去加载。

## 10、为什么需要双亲委派模型？

**避免重复加载 + 避免核心类篡改**

## 11、怎么打破双亲委派模型？

打破双亲委派机制要继承ClassLoader类，然后重写loadClass() 和 findClass()方法。

重写findClass方法是为了能够找到指定位置的指定class文件或者jar文件来进行加载

还有一个就是在 JDBC中的Driver就有打破双亲委派模式，执行获取连接时，引入线程上下文类加载器，程序就可以把原本需要由启动类加载器进行加载的类，由应用程序类加载器去进行加载了。

## 12、JVM性能调优？

##### 1、设定堆内存大小

-Xms：启动JVM时的堆内存空间。

-Xmx：堆内存最大限制

##### 2、设定新生代大小。新生代不宜太小，否则会有大量对象涌入老年代

-XX：NewSize ：新生代大小

-XX：NewRatio  新生代和老年代占比

-XX：SurvivorRatio ：伊甸园空间和幸存者空间的占比

-XX:MaxTenuringThreshold：对象进⼊⽼年代的年龄阈值。

##### 3、设定垃圾回收器  

年轻代用

-XX：+UseParNewGC

老年代用

-XX：+UseConcMakSweepGC

## 13、Java内存模型？

定义了线程和主内存之间的抽象关系，即 JMM 定义了 JVM 在计算机内存(RAM)中的工作方式

## 14、堆跟栈的区别

最主要的区别就是栈内存用来存储局部变量和方法调用。

而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量。他们指向的对象都存储在堆内存中。

堆是线程共享的，栈是线程私有的。栈的内存要远远小于堆的内存。

## 15、常见的垃圾回收算法有哪些？简述其原理？

GC最基础的算法有三种：引用计数算法、标记清除算法、复制算法、标记整理算法，我们常用的垃圾回收器一般都采用分代收集算法。

#### 引用计数器：

**原理**：只要对象之间互相有引用，GC 就不进行垃圾回收

**缺点**：

- 每次对对象赋值时要维护引用计数器，且计数器本身也有一定的消耗
- 比较难处理循环引用

JVM 的实现一般不采用这种方式。

#### 标记清除算法：

老年代一般是由标记清除或是标记清除与标记整理的混合实现。

**原理**：算法分为 标记 和 清除 两个阶段。首先标记出所有需要回收的对象（标记），在标记完成后统一回收所有被标记的对象（清除）。

**优点**：

- 所有的操作都是在一块内存空间上完成的，不需要额外的空间

**缺点**：

- 标记 和 清除 两个过程的效率都不高：标记需要扫描1次，清除也需要扫描1次，两次扫描，耗时严重
- 标记清除后，会产生大量不连续的内存碎片，空间碎片太多可能会导致以后程序在运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾回收。

#### 复制算法：

年轻代中使用的是Minor GC，这种 GC 算法采用的是复制算法。

**原理**：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

**优点**：

- 没有标记和清除的过程，效率高
- 内存在分配时不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可

**缺点**：

- 将实际可用的内存空间缩小为了原来的一半

#### 标记整理算法：

标记整理一般发生在老年代区域。

**原理**：和标记清除算法一样，不同的是，在标记完后，不是直接清理可回收对象，而是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。

**优点**：

- 清理时，不会产生大量连续的内存碎片

**缺点**：

- 需要移动对象的成本

老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收;

## 15、分代收集下的年轻代和老年代应该采用什么样的垃圾回收算法？

**1、年轻代的回收算法 (主要以复制算法为主)**

1. 所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。

   

2. 新生代内存按照 8:1:1 的比例分为一个 eden 区和两个 survivor（survivor0、 survivor1）区。大部分对象在 Eden 区中生成。回收时先将 Eden 区存活对象复制到一个 survivor0 区，然后清空 eden 区，当这个 survivor0 区也存放满了时，则将 eden 区和 survivor0 区存活对象复制到另一个 survivor1 区，然后清空 eden 区 和这个 survivor0 区，此时 survivor0 区是空的，然后将survivor0 区和 survivor1 区交换，即保持 survivor1 区为空， 如此往复。

3. 当 survivor1 区不足以存放 Eden 区 和 survivor0区 的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC（Major GC），也就是新生代、老年代都进行回收。

4. 新生代发生的 GC 也叫做 Minor GC，MinorGC 发生频率比较高（不一定等 Eden 区满了才触发）。

**2、年老代的回收算法（主要以 标记整理为主）**

1. 在年轻代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。
2. 内存比新生代也大很多（大概比例是1 : 2），当老年代内存满时触发 Major GC 即 Full GC，Full GC 发生频率比较低，老年代对象存活时间比较长，存活率比较高。

## 15、都有哪些垃圾回收器？

- **1. (瑟瑞又) Serial 收集器（复制算法)**

**新生代单线程收集器**，标记和清理都是单线程，优点是简单高效。是 client 级别默认的 GC 方式，可以通过 -XX:+UseSerialGC 来强制指定。

- **2. Serial Old 收集器（标记-整理算法）**

**老年代单线程收集器**，Serial 收集器的老年代版本。

- **3. ParNew 收集器（停止-复制算法）**

**新生代收集器**，可以认为是 Serial 收集器的多线程版本，在多核 CPU 环境下有着比 Serial 更好的表现。

- **4. Parallel Scavenge 收集器（停止-复制算法）**

**并行收集器**，追求高吞吐量，高效利用 CPU。

- **5. Parallel Old 收集器（停止-复制算法）**

Parallel Old 收集器的老年代版本，并行收集器，吞吐量优先。

- **6. CMS(Concurrent Mark Sweep)收集器（标记-清除算法）**

高并发、低停顿，追求最短 GC 回收停顿时间，cpu 占用比较高，响应时间快，停顿时间短，多核 cpu 追求高响应时间的选择。

CMS 是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。

主要缺点：对 CPU 资源敏感、无法处理浮动垃圾、它使用的回收算法“标记-清除”算法会导致收集结束时会有大量空间碎片产生。

- **7. G1**

G1 是采众家之长，力求到达一种完美。它吸取了增量收集优点，把整个堆划分为一个一个等大小的区域（region）。内存的回收和划分都以region(区域)为单位；G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region（区域）；

同时，它也吸取了 CMS 的特点，把这个垃圾回收过程分为几个阶段，分散一个垃圾回收过程；

G1 也认同分代垃圾回收的思想，认为不同对象的生命周期不同，可以采取不同收集方式，因此，它也支持分代的垃圾回收。

## 16、什么是类的加载？

java文件通过编译器变成了.class文件，接下来类加载器又将这些.class文件加载到JVM中。

其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。

## 17、类加器有哪些？

启动类加载器：Bootstrap  ClassLoader  负责加载在 JDK\ jre \ lib 下的类

扩展类加载器    Extension  ClassLoader   负责 JDK \ jre \ lib \ ext 目录中的类    开发者可以直接使用扩展类加载器

应用程序类加载器  ： Application  ClassLoader  它负责加载用户路径（ClassPath）所指定的类，开发者可以直接使用该类加载器。

自定义类加载器



## 19、JVM 调优命令/监控工具？

1. jps ：查看当前 Java 进程
2. jstat：显示虚拟机运行数据
3. jmap：内存监控
4. jhat：分析 heapdump 文件
5. jstack：线程快照
6. jinfo：虚拟机配置信息

## 20、JVM调优工具？

1、jconsole  是从java5开始，在JDK中自带的java监控和管理控制台，用于对 JVM中内存，线程 和类等的监控

2、j visual vm   JDK 自带全能工具，可以分析内存快照、线程快照：监控内存变化、GC变化等。

3、MAT  一个基于Eclipse 的内存分析工具，是一个快速、功能丰富的 Java heap 分析工具，它可以帮助我们查找内存泄漏和减少内存消耗

## 21、如何利用监控工具调优

**1、堆信息查看**

1. 可查看堆空间大小分配（年轻代、年老代、持久代分配）

2. 提供即时的垃圾回收功能

3. 垃圾监控（长时间监控回收情况）

4. 查看堆内类、对象信息查看：数量、类型等

5. 对象引用情况查看

有了堆信息查看方面的功能，我们一般可以顺利解决以下问题：

1. 年老代年轻代大小划分是否合理

2. 内存泄漏垃

3. 圾回收算法设置是否合理

**2、线程监控**

线程信息监控：系统线程数量

线程状态监控：各个线程都处在什么样的状态下

Dump 线程详细信息：查看线程内部运行情况

死锁检查

**3、 热点分析**

1. CPU 热点：检查系统哪些方法占用的大量 CPU 时间；

2. 内存热点：检查哪些对象在系统中数量最大（一定时间内存活对象和销毁对象一起统计）这两个东西对于系统优化很有帮助。我们可以根据找到的热点，有针对性的进行系统的瓶颈查找和进行系统优化，而不是漫无目的的进行所有代码的优化。

**4、快照**

快照是系统运行到某一时刻的一个定格。在我们进行调优的时候，不可能用眼睛去跟踪所有系统变化，依赖快照功能，我们就可以进行系统两个不同运行时刻，对象（或类、线程等）的不同，以便快速找到问题。

举例说，我要检查系统进行垃圾回收以后，是否还有该收回的对象被遗漏下来的了。那么，我可以在进行垃圾回收前后，分别进行一次堆情况的快照，然后对比两次快照的对象情况。

**5、内存泄露检查**

内存泄漏是比较常见的问题，而且解决方法也比较通用，这里可以重点说一下，而线程、热点方面的问题则是具体问题具体分析了。

内存泄漏一般可以理解为系统资源（各方面的资源，堆、栈、线程等）在错误使用的情况下，导致使用完毕的资源无法回收（或没有回收），从而导致新的资源分配请求无法完成，引起系统错误。内存泄漏对系统危害比较大，因为它可以直接导致系统的崩溃。

## 22、JMM  内存模型的理解

处理器和内存不是同数量级，所以需要在中间建立中间层，也就是高速缓存，这会引出缓存一致性问题。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，有可能操作同一位置引起各自缓存不一致，这时候需要约定协议在保证一致性。

Java 内存模型：屏蔽掉了各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致性的内存访问效果

- **主内存与工作内存**

Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。

Java 内存模型规定了所有的变量都存储在主内存中，每个线程有自己的工作线程，保存主内存副本拷贝和自己私有变量，不同线程不能访问工作内存中的变量。线程间变量值的传递需要通过主内存来完成。

# 六、多线程

## 2、sleep() 和 wait() 的区别？？

1、sleep() 方法可以在任何地方使用，而 wait() 方法则只能在同步方法或同步块中使用；

2、sleep() 是线程类（Thread）的方法，调用会暂停此线程指定的时间，但监控(monitor)依然保持，不会释放对象锁，到时间自动恢复；wait() 是 Object 的方法，调用会放弃对象锁，进入等待队列，待调用 notify()/notifyAll() 唤醒指定的线程或者所有线程，才会进入锁池，再次获得对象锁才会进入运行状态。

## 4、线程同步的方法？

1. 使用 Synchronized 关键字；
2. wait 和 notify；
3. 使用特殊域变量 volatile 实现线程同步；
4. 使用可重入锁实现线程同步；
5. 使用阻塞队列实现线程同步；

## 5、线程的几种状态？

1、新建状态：新创建了一个线程对象

2、就绪状态：线程对象创建后，其他线程调用了该对象的start（）方法。该状态的线程位于“可运行线程池”中，变的可运行，只等待获取cpu的使用权，即在就绪状态的进程除CPU之外，其他的运行所需资源都已全部获得。

3、运行状态：就绪状态的线程获取了CPU、执行程序代码。

4、阻塞状态：阻塞状态时线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。

阻塞的情况分三种：

（1）等待阻塞，就是线程执行wait（）方法

（2）同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程池放入“锁池”中。

（3）其他阻塞：运行的线程执行sleep（）或者 join（）方法

5、死亡状态：线程执行完了，或者因异常退出了run（）方法，该线程结束生命周期。



## 6.线程创建的三种方式

1. 继承Thread类创建线程类

2. 通过Runable接口创建线程类

3. 通过实现callable接口的方式，需要重写其中的call方法。启动线程时，需要新建一个Callable的实例，再用FutureTask实例包装它，最终，再包装成Thread实例，调用start方法启动，并且，可以通过FutureTask的get方法来获取返回值。

4. 使用线程池创建

   一般使用接口的形式实现线程的创建，如果继承了thread类，会减少这个类的扩展性，java只能单继承，但是可以实现多个接口

## 6、如何创建线程池？

1、通过 ThreadPoolExecutor 的构造方法实现

2、通过 Executor 框架的工具类 Executors 来实现：

《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的人更加明确线程池的运行规则，规避资源耗尽的风险

Executors 返回线程池对象的弊端如下：

FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致OOM。
CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。

## 7、线程池三大特征

线程安全在三个方面体现：

原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic，synchronized）；

可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized、volatile）；

有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before 原则）。

## 8、对 ThreadLocal 的理解？

ThreadLocal 是线程本地存储

##### ThreadLocal主要有如下2个作用

1. 保证线程安全
2. 在线程级别传递变量



1、每一个线程都独享一个 ThreadLocal，我们可以在接收请求的时候 set 特定内容，在需要的时候 get 这个值。

2、 ThreadLocal 提供 get 和 set 方法，为每一个使用这个变量的线程都保存有一份独立的副本。

​	1、get() 方法是用来获取 ThreadLocal 在当前线程中保存的变量副本；

​    2、set() 用来设置当前线程中变量的副本；

​    3、 remove() 用来移除当前线程中变量的副本；

## 9.都有哪些线程池

​									

**newSingleThreadExecutor** ：单个线程的线程池

**newFixedThreadExecutor**：固定数量的线程池

**newCacheThreadExecutor**：可缓存线程池，当线程池大小超过了处理任务所需的线程，那么就会回收部分空闲（一般是60秒无执行）的线程，当有任务来时，又智能的添加新线程来执行。

**newScheduleThreadExecutor**：大小无限制的线程池，支持定时和周期性的执行线程

线程池的创建：避免使用Executors默认，我们可以自己直接调用ThreadPoolExecutor的构造函数来自己创建线程池

## 9、线程池都有哪些拒绝策略

（1）ThreadPoolExecutor.AbortPolicy  丢弃任务，并抛出异常。

（2）ThreadPoolExecutor.CallerRunsPolicy：该任务被线程池拒绝，会将这个任务交给提交任务的线程来执行。（这样的话提交的任务就不会被丢弃而造成业务损失，同时这种谁提交谁负责的策略必须让提交线程来负责执行，如果任务比较耗时，那么这段时间内提交任务的线程也会处于忙碌状态而无法继续提交任务，这样也就减缓了任务的提交速度，这相当于一个负反馈。也有利于线程池中的线程来消化任务）

（3）ThreadPoolExecutor.DiscardOldestPolicy ： 抛弃队列最前面的任务，然后重新尝试执行任务。

（4）ThreadPoolExecutor.DiscardPolicy，丢弃任务，不过也不抛出异常。

## 10、线程池的作用

　第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 

　第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 

　第三：提高线程的可管理性。 

## 11、线程池核心参数

**corePoolSize** ：线程池的核心线程数。核心线程会一直存在，哪怕没有任务执行
**maximumPoolSize** ：线程池所能容纳的最大线程数。
**keepAliveTime** ：非核心线程闲置时的超时时长。超过该时长，非核心线程就会被回收。
**allowCoreThreadTimeout**：是否允许核心线程超时
**workQueue** ：线程池中的任务队列。
**threadFactory：**线程工厂，默认值DefaultThreadFactory。

**handler** ：拒绝策略





# 七、并发/锁

## 1、synchronized 和 Volatile的比较？

**synchronized 是悲观锁，属于抢占式、会引起其他线程阻塞。**



1. volatile 本质是在告诉 JVM当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
2. volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的。
3. volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。
4. volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。
5. volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。

## synchronized

反编译

Monitor enter

 Monitor exit

在 JDK6之前，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因；

JDK6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。

## volatile

volatile 关键字是用来保证有序性和可见性的。这跟 Java 内存模型有关。我们所写的代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU 也会做重排序的，这样做是为了，提高 CPU 的执行效率。所以有 happens-before 规则，其中有条就是 volatile 变量规则：就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。

被 volatile 修饰的共享变量，就具有了以下两点特性：

1 . 保证了不同线程对该变量操作的内存可见性;

2 . 禁止指令重排序。

## happens-before规则

**程序次序规则：**

在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变。

管程锁定规则：就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果！(管程是一种通用的同步原语，synchronized就是管程的实现）

**volatile变量规则：**就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。

**线程启动规则：**在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。

**线程终止规则：**在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。

线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。

传递性规则：这个简单的，就是happens-before原则具有传递性，即hb(A, B) ， hb(B, C)，那么hb(A, C)。

对象终结规则**：**这个也简单的，就是一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before它的finalize()方法。



## 2、说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化

JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。

### 锁粗化

  锁粗化就是将多次连接在一起的加锁、解锁操作合并为一次操作。将多个联系的锁扩展为一个范围更大的锁。

比如每次调用StringBuffer的append方法都需要加锁和解锁，如果虚拟机检测到有一系列连串的对同一对象加锁和解锁操作，就会在在第一次append方法时进行加锁，在最后一次append方法结束后进行解锁。

### 锁消除

删除不必要的加锁操作，如果虚拟机在一段代码中，检测到那些共享数据不可能存在竞争，就是堆上的数据不会逃逸出当前线程，则认为此代码是线程安全的，就执行锁消除，无需加锁

### 自旋锁

所谓自旋锁，就是让某线程进入已被其它线程占用的同步代码时等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。这里等待的方式就是执行一段无意义的循环。

### 适应性自旋锁

与线程阻塞相比，自旋会浪费大量的处理器资源。这是因为当前线程仍处于运行状况，只不过跑的是无用指令。它期望在运行无用指令的过程中，锁能够被释放出来。

**即就是如果在自旋的时候获取到锁，则会增加下一次自旋的时间，否则就稍微减小下一次自旋时长**；



#### 锁标志位

无锁状态的锁标志位为 01 ；

 偏向锁的锁标志位也是 01 不过对象头里有一个 1bit的空间来指示是否是偏向锁 是的话 1bit 就为1；

轻量级锁标志位 00 

重量级锁标志位 10

**但要注意的是除了偏向锁可以恢复到无锁状态以外，其他的都不能降级** 

### 偏向锁

引入偏向锁的目的和引入轻量级锁的目的很像，它们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

如果一个线程获得了锁，那么锁就进入偏向模式，偏向锁会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步操作。

对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，偏向锁失败后，并不会立即膨胀为重量级锁，会先升级为轻量级锁。

#####   1、**加锁过程**

​		检查对象头中 Mark Word 里的 Thread ID 是否是此线程的 ID，是的话就说明此线程获取锁成功。

如果不是的话，那么还需检查 Mark Word 中偏向锁的标识是否设置成 1，如果没有设置，则使用 CAS 竞争锁；如果设置了，则尝试使用 CAS 将对象头的偏向锁指向当前线程。

##### 2、偏向锁的撤销

当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（GC 的工作也需要在安全点进行，在这个时间点上没有正在执行的字节码）；

它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，则判断偏向所有者现在有没有持有该偏向锁，**偏向所有者正在持有该偏向锁的话，将其撤销为轻量级锁** (就是这个时候偏向锁升级为轻量级锁) 。**偏向所有者没有正在持有 待撤销的偏向锁，如果允许重偏向 则偏向锁 变可偏向锁；否则偏向锁撤销为无锁**，最后唤醒暂停的线程。

**如何判断偏向所有者没有正在持有该偏向锁？**

遍历它的栈，看是否能找到关联该锁的锁记录，如果找到，则正在持有，如果没找到，则没有持有。

**偏向所有者正在持有该偏向锁，如何将其撤销为轻量级锁？**

遍历偏向所有者的栈，修改与该锁关联的所有锁记录，让偏向所有者以为它对该对象加的就是轻量级锁。



### 轻量级锁

**多个线程在不同时刻请求同一把锁**，也就是不存在锁竞争的情况。偏向锁相对于重量级锁的一个优点就是：因为线程在竞争资源时采用的是自旋，而不是阻塞，也就避免了线程的切换带来的时间消耗，提高了程序的响应速度。

##### 轻量级锁的获取

线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，然后线程尝试使用 CAS 将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获取到锁。如果失败，表示其他线程竞争锁。

##### 轻量级锁的撤销

轻量级锁解锁时，会使用原子的CAS操作将Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁(**多个线程在相同时刻竞争同一把锁**)；



#### 轻量级锁什么时候变成重量级锁

存在锁竞争的时候

如果存在锁竞争，除了互斥量开销外，还会额外发生 CAS 操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！



### 重量级锁

  重量级锁会阻塞 和 唤醒请求加锁的线程。**针对的是多个线程同时竞争同一把锁的情况。**JVM采用自适应自旋，来避免在面对非常小的同步代码块时，仍会被阻塞和唤醒的状况。



## 3、锁膨胀过程

1. **从无锁到偏向锁**

一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁，偏向第一个线程。这个线程在修改对象头成为偏向锁的时候使用 CAS 操作，并将对象头中的 ThreadID 改成自己的 ID，之后再次访问这个对象时，只需要对比 ID，不需要再使用 CAS.

2. **从偏向锁到轻量级锁**

一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象是偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁**（ 偏向锁就是这个时候升级为轻量级锁的）**。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。

3. **从轻量级锁到重量级锁**

轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止 CPU 空转。

## 4、synchronized和ReentrantLock 的区别

##### **1、两者都是可重入锁**

同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。

##### 2、synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API

synchronized 是Java关键字。依赖于 JVM 实现的，**底层原理：monitorenter 和 monitorexit 指令**

ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成）

##### 3、 ReentrantLock 比 synchronized 增加了一些高级功能更灵活

- 等待可中断；
- 可实现公平锁；
- 可实现选择性通知（锁可以绑定多个条件）

## 6、产生死锁的条件？

1、互斥条件：一个资源每次只能被一个进程使用

2、请求于保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

3、不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。

4、循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。





 ## 11、Lock
Lock：拥有synchronize相同的语义，但是添加一些其他特性，如中断锁等候和定时锁等候，所以可以使用lock代替synchronize
底层是reentrantlock 继承AQS，它的存储结构是双向链表+一个state状态值。当一个线程获取锁时，通过CAS去修改state的值。修改成功，代表没有线程竞争，获取到了锁。修改失败，会尝试再次CAS获取一次锁，还失败就将当前线程加入双向链表中，然后通过自旋，判断当前节点是否可以获取锁。

释放锁的时候不用CAS，直接设置state状态值。更新下一个链表中的线程等待节点
## 12、synchronized和lock的区别

一个基于JVM，是java关建字。一个基于API，是java类

synchronized不用操心锁的释放，lock必须手动释放锁，为了避免死锁，需要在finally块中释放锁

lock可以响应中断，可以实现公平。synchronized不可以，不公平
## 13、悲观锁和乐观锁

##### 悲观锁：

每次拿到共享资源就上锁，其余线程访问共享资源就会阻塞直到它拿到锁。

比如mysql数据库中的行锁、表锁，java中synchronized和Reentranlock等独占锁就是悲观锁的实现

##### 乐观锁：

每次访问共享资源的不上锁，但是在更新的时候会判断有没有人更新这个数据，可以使用版本号机制和CAS算法实现。

乐观锁有两种实现方式

1.版本号机制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数，当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当 前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。

### 

2.CAS算法：不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步。

涉及到3个操作数：需要读写的内存值V，进行比较的值A ，写入的新值B。只有当V=A时，才会用B来更新V的值，V不等A的情况下，一般会采用自旋操作，不断重试，直到修改成功

CAS具有原子性，它的原子性由CPU硬件指令实现保证，即使用 JNI 调用 Native 方法调用由 C++ 编写的硬件级别指令，JDK中提供了 Unsafe类执行这些操作；

缺点：

只能保证一个共享变量的原子操作，可以使用锁或者利 用 AtomicReference 类把多个共享变量合并成一个共享变量来操作。

循环时间长开销大

ABA 问题 加版本号

（Unsafe，是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。）

## CAS

compare and swap

old new 

## 14、AQS

抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock

AQS维护了一个 volatile 修饰的 **state**变量**判断是否阻塞**线程占有时 用CAS  + 1 直到为0时释放锁。

AQS还有一个 CLH队列，当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，等待被唤醒，在等待唤醒的时候，会使用自旋的方式，不停地尝试获取锁；

### AQS 对资源的共享模式有哪些？

1. Exclusive（独占）：只有一个线程能执行，如：ReentrantLock，又可分为公平锁和非公平锁：

2. Share（共享）：多个线程可同时执行，如：（读写锁）ReadWriteLock。，CountDownLatch（计数器）、Semaphore（信号量）、CountDownLatch、 CyclicBarrier

   CountDownLatch 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 CyclicBarrier 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。对于 CountDownLatch 来说，重点是“一个线程等待”，而其他的 N 个线程在完成“某件事情”之后，可以终止，也可以等待。而对于 CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。

   

### AQS 底层使用了模板方法模式，你能说出几个需要重写的方法吗？

1. isHeldExclusively() ：该线程是否正在独占资源。只有用到 condition 才需要去实现它。
2. tryAcquire(int) ：独占方式，尝试获取资源，成功则返回 true，失败则返回 false。
3. tryRelease(int) ：独占方式，尝试释放资源，成功则返回 true，失败则返回 false。
4. tryAcquireShared(int) ：共享方式，尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
5. tryReleaseShared(int) ：共享方式，尝试释放资源，成功则返回 true，失败则返回 false。





# 八、Redis

## 1、Redis五种数据类型

**String** ： 常规key-value缓存应用。常规计数: 限制用户访问频率，微博粉丝数。。

**hash**  ：value就是一个map结构，可以用来 存储部分变更数据，如用户信息等。

**list** ： 按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。可以做关注列表，粉丝列表，还可以做消息队列系统

**set**：提供了求交集、并集、差集等操作，可以用实现共同好友功能，利用唯一性，统计访问网站的所有独立ip

**ZSet** ： 需要一个有序不重复的集合列表的时候，可以用这个，可以实现排行榜功能

- HyperLogLog：计算近似值的。
- GEO：地理位置。

- BIT：一般存储的也是一个字符串，存储的是一个byte[]



## 1、Redis 为什么这么快？

1. 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速；
2. 数据结构简单，对数据操作也简单；
3. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
4. 使用多路 I/O 复用模型，非阻塞 IO。 WIN系统用的 select模型，linax 用的 epoll模型。
5. C语言实现，效率高



## 2、分布式锁

在多线程并发的情况下，我们可以使用锁来保证一个代码块在同一个时间内只能由一个线程访问。比如synchronized 关键字。这样子可以保证在同一个JVM进程中内的多个线程同步执行。分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁实现，如果不同的系统或同一个系统的不同主机之间共享了某个资源时，就需要互斥来防止彼此干扰来保证一致性。

##### 分布式锁的实现有三种： 

一是基于数据库的分布式锁

二是基于Redis分布式锁

三是基于Zookeeper 分布式锁

##### Redis锁的实现：

里边有三个核心要素， 1、加锁  2、解锁   3、锁超时

加锁就是设置 Key  value  key是锁的唯一标识，按业务来决定命名，value可以是随机生成的UUID

有加锁就得有解锁，当得到锁的线程执行完任务，需要释放锁，以便其他线程可以进入。解锁就比较简单了，就是删除Key。

锁超时就是如果一个得到锁的线程在执行任务的过程中挂掉，没来得及释放锁，那这块资源将会永远的锁住，别的线程都进不来，所以要Key必须要设置一个超时时间，以保证即使没有被释放，这把锁也要在一定的时间自动释放，避免死锁。

不过只有这样是有问题的。假如一个线程得到了锁，并且设置的超时时间是30秒，如果某些原因导致线程A执行的很慢很慢，过了30秒都没执行完，这时候锁过期自动释放，线程B得到了锁。随后线程A执行完了任务，然后删除Key释放锁，但这个时候线程B还没执行完，所以线程A实际上删除的是线程B加的锁。

所以我们需要在释放锁之前加一个判断，验证当前的锁是不是自己加的锁。至于具体的实现，可以在释放锁的时候，通过锁的默认value值UUID判断是不是该锁，若是该锁，则执行删除Key进行锁释放。

还有一个问题就是出现并发的可能性，还是刚才所说的场景，虽然我们避免了线程A误删掉key的情况，但是同一时间有A，B两个线程在访问代码块，仍然是不完美的。所以我们可以让获得锁的线程开启一个守护线程，用来给快要过期的锁“续航”，比如设置的是过期时间是三十秒，当过去了29秒，线程A还没执行完，这个时候守护线程为这把锁“续命20秒”。守护线程从29秒的时候开始执行，每二十秒执行一次。直到线程A执行完，然后限时关掉守护线程。

Redis实现分布式都是用Redisson框架，直接封装好的，我刚才说的所有情况他都可以避免，很方便，里边就有一个看门狗机制，就和我刚才说的那个守护线程的作用差不多。

## 2、Redis 的线程模型？

Redis 内部使用文件事件处理器  （file event handler） ，这个文件事件处理器是单线程的，所以Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket ，根据 socket 上的事件来选择对应的事件处理器进行处理。

文件事件处理器的结构包含 4 个部分：

1. 多个 socket 。
2. IO 多路复用程序。
3. 文件事件分派器。
4. 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）。

多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。

## 3、Redis的持久化方式？

##### RDB

RDB 持久化，是指在指定的时间间隔内将内存中的**数据集快照**写入磁盘。实际操作过程是，fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。整个过程中，主进程不进行任何的io操作，这就确保了极高的性能

##### 什么时候触发 RDB 持久化机制？

 shutdown时、执行命令save或者bgsave ；

##### AOF

AOF持久化，以日志的形式记录服务器所处理的每一个**写、删除操作**，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录，里边都是一些按照协议生成的字符串。Redis 中AOF提供了 3 种同步策略，即每秒同步、每次修改同步和不同步。

##### aof重写机制

当AOF文件增长到一定大小的时候Redis能够日志文件进行重写 。

1、当AOF文件大小的增长率大于该配置项时自动开启重写（这里指超过原大小的100%）。默认超过原大小100%大小时重写可以改到适当的数值。

auto-aof-rewrite-percentage 100；

2、当AOF文件大小大于该配置项时自动开启重写；（64M）默认64太小了，一般设置到5G以上。

auto-aof-rewrite-min-size 64mb

## 4、Redis混合持久化机制

4.0版本的混合持久化默认关闭的，通过aof-use-rdb-preamble配置参数控制，yes则表示开启，no表示禁用，5.0之后默认开启。

当开启混合持久化时，fork出的子进程先将共享的内存副本全量的以RDB方式写入aof文件，然后在将重写缓冲区的增量命令以AOF方式写入到文件，写入完成后通知主进程更新信息，并将新的含有RDB格式和AOF格式的AOF文件替换旧的的AOF文件。简单的说：新的AOF文件前半段是RDB格式的全量数据后半段是AOF格式的增量数据，

优点：混合持久化结合了RDB持久化 和 AOF 持久化的优点, 由于绝大部分都是RDB格式，加载速度快，同时结合AOF，增量的数据以AOF方式保存了，数据更少的丢失。

缺点：兼容性差，一旦开启了混合持久化，在4.0之前版本都不识别该aof文件，同时由于前部分是RDB格式，阅读性较差

## 5、rdb和aof优势劣势

rdb 适合大规模的数据恢复，对数据完整性和一致性不高 ，  在一定间隔时间做一次备份，如果redis意外down机的话，就会丢失最后一次快照后的所有操作；性能比较好
aof  性能较差但数据完整性比较好

1.官方建议   两种持久化机制同时开启，如果两个同时开启  优先使用aof持久化机制  

## 6、Redis主从复制



![1627576880(1)](C:\Users\HaoDong.Kang\Desktop\1627576880(1).jpg)

## 7、Redis哨兵模式

哨兵的核心功能是主节点的自动故障转移。

监控（Monitoring）：哨兵会不断地检查主节点和从节点是否运作正常。

自动故障转移（Automatic Failover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。

配置提供者（Configuration Provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。

通知（Notification）：哨兵可以将故障转移的结果发送给客户端。

其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移；而配置提供者和通知功能，则需要在与客户端的交互中才能体现。

## 8、Redis哨兵模式基本原理

主观下线：主观下线的意思是一个哨兵节点“主观地”判断下线；在心跳检测的定时任务中，如果其他节点超过一定时间没有回复，哨兵节点就会将其进行主观下线。

客观下线：哨兵节点在对主节点进行主观下线后，会通过sentinel is-master-down-by-addr命令询问其他哨兵节点该主节点的状态；如果判断主节点下线的哨兵数量达到一定数值，则对该主节点进行客观下线。（一定数值为大多数，三个哨兵 max=2，五个哨兵 max=3所以哨兵最少要有三个）

定时任务：每个哨兵节点维护了3个定时任务：

1.每10秒通过向主从节点发送info命令获取最新的主从结构；

  发现slave节点

  确定主从关系

2.每2秒通过发布订阅功能获取其他哨兵节点的信息； 交互对节点的“看法”和自身情况

3.每1秒通过向其他节点发送ping命令进行心跳检测，判断是否下线。

  心跳检测，失败判断依据

## 9、选举领导者哨兵节点

当主节点被判断客观下线以后，各个哨兵节点会进行协商，选举出一个领导者哨兵节点，并由该领导者节点对其进行故障转移操作。

监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法；Raft算法的基本思路是先到先得：即在一轮选举中，哨兵A向B发送成为领导者的申请，如果B没有同意过其他哨兵，则会同意A成为领导者。一般来说，哨兵选择的过程很快，谁先完成客观下线，一般就能成为领导者。

## 10、从节点成为主节点的原则/哨兵故障转移步骤

在从节点中选择新的主节点：选择的原则是，

1.首先过滤掉不健康的从节点；

2.然后选择优先级最高的从节点（由replica-priority指定）；如果优先级无法区分，

3.则选择复制偏移量最大的从节点；如果仍无法区分，

4.则选择runid最小的从节点。

更新主从状态：通过（slaveof no one）命令，让选出来的从节点成为主节点；并通过slaveof命令让其他节点成为其从节点。

将已经下线的主节点保持关注，当它新上线后设置为新的主节点的从节点

## 11、哨兵模式的优缺点

优点：在主从复制的基础上，哨兵引入了主节点的自动故障转移，进一步提高了Redis的高可用性；

缺点：1、哨兵无法对**从**节点进行自动故障转移；

2、哨兵仍然没有解决写操作无法负载均衡；



## 12、redis cluster高可用集群是什么？

redis cluster集群是一个由多个主从节点群组成的分布式服务器群，它具有复制、高可用和分片特
性。Redis cluster集群不需要sentinel哨兵也能完成节点移除和故障转移的功能。需要将每个节点
设置成集群模式，这种集群模式没有中心节点，可水平扩展，据官方文档称可以线性扩展到
1000节点。

## 13、请说说你们生产环境中的 Redis 是怎么部署的？

- Redis Cluster ，10 台机器，5 台机器部署了 Redis 主实例，另外 5 台机器部署了 Redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰 qps 可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求每秒。
- 机器是什么配置？32G 内存 + 8 核 CPU + 1T 磁盘，但是分配给 Redis 进程的是 10G 内存，一般线上生产环境，Redis 的内存尽量不要超过 10G，超过 10G 可能会有问题。那么，5 台机器对外提供读写，一共有 50G 内存。
- 因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，Redis 从实例会自动变成主实例继续提供读写服务。
- 你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb 。100 条数据是 1mb ，10 万条数据是 1G 。常驻内存的是 200 万条商品数据，占用内存是 20G ，仅仅不到总内存的 50% 。目前高峰期每秒就是 3500 左右的请求量

## 14、如何提高 Redis 命中率？

- 缓存预加载
- 增加缓存存储量
- 调整缓存存储数据类型
- 提升缓存更新频次

## 15、对 Redis 进行性能优化，有些什么建议？

1、Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件。

2、Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。

3、尽量避免在压力很大的主库上增加过多的从库。

4、主从复制不要用图状结构，用单向链表结构更为稳定，即：`Master <- Slave1 <- Slave2 <- Slave3...` 。

5、Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。

# 九、RabbitMQ

## 1、消息队列的基本作用？

- #### **解耦**

A 系统通过接口调用发送数据到 B、C、D 三个系统。那如果现在 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？现在 A 系统又要发送第二种数据了呢？这样的话 A 系统的维护成本就非常的高，而且 A 系统要时时刻刻考虑B、C、D、E 四个系统如果出现故障该怎么办？A 系统是重发还是先把消息保存起来呢？使用消息队列就可以解决这个问题。A 系统只负责生产数据，不需要考虑消息被哪个系统来消费。

- #### **异步**

A 系统需要发送个请求给 B 系统处理，由于 B 系统需要查询数据库花费时间较长，以至于 A 系统要等待 B 系统处理完毕后再发送下个请求，造成 A 系统资源浪费。使用消息队列后，A 系统生产完消息后直接丢进消息队列，不用等待 B 系统的结果，直接继续去干自己的事情了。

- #### **削峰**

A 系统调用 B 系统处理数据，每天 0 点到 12 点，A 系统风平浪静，每秒并发请求数量就 100 个。结果每次一到 12 点 ~ 13 点，每秒并发请求数量突然会暴增到 1 万条。但是 B 系统最大的处理能力就只能是每秒钟处理 1000 个请求，这样系统很容易就会崩掉。这种情况可以引入消息队列，把请求数据先存入消息队列中，消费系统再根据自己的消费能力拉取消费。

## 2.AMQP模型的几大组件？

- 交换器 (Exchange)：消息代理服务器中用于把消息路由到队列的组件。
- 队列 (Queue)：用来存储消息的数据结构，位于硬盘或内存中。
- 绑定 (Binding)：一套规则，告知交换器消息应该将消息投递给哪个队列。

## 3、如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？

#### 保证幂等性

1. 写数据时，先根据主键查一下这条数据是否存在，如果已经存在则 update；
2. 数据库的唯一键约束也可以保证不会重复插入多条，因为重复插入多条只会报错，不会导致数据库中出现脏数据；
3. 加全局唯一id，判断；

## 4、如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？

##### （1）生产者弄丢了数据

可以用事务实现，不过不推荐，太耗性能。所以一般来说，如果我们要确保说发送rabbitmq的消息别丢，可以开启confirm模式，在生产者那里开启confirm模式，然后再开启失败回调，你每次写的消息都会分配一个唯一的id，然后如果写入了rabbitmq中，rabbitmq会给你回传一个ack消息，告诉你这个消息ok。如果rabbitmq没能处理这个消息，会回调你一个nack接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息id的状态，如果超过一定时间还没接收到这个消息的回调，那么我们就可以重发。

```java
（发送方确认开启）
connectionFactory.setPublisherConfirms(true);
（开启失败回调） 
template.setMandatory(true); 
（指定失败回调接口的实现类 ）
template.setReturnCallback(new MyReturnCallback());
```

 

事务机制和confirm机制最大的不同在于，事务机制是同步的，我们提交一个事务之后会阻塞在那，但是confirm机制是异步的，我们发送这个消息之后就可以发送下一个消息了，然后那个消息rabbitmq接收了之后会异步回调我们一个接口通知我们这个消息接收到了。

##### （2）rabbitmq弄丢了数据

设置持久化有两个步骤，第一个是创建queue的时候将其设置为持久化，这样就可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里的数据；第二个是发送消息的时候将消息的deliveryMoe设置为2，就是将消息设置为持久化的，此时rabbitmq就会将消息持久化到磁盘上去。必须要同时设置这连个持久化才行，rabbitmq哪怕挂了，再次重启，也会从磁盘上重启恢复queue，恢复这个queue里的数据。

而且持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者ack，所以哪怕是在持久化到磁盘之前，rabbitmq挂了，数据丢了，生产者收不到ack，你也可以自己重发的。

哪怕是我们给rabbitmq开启了持久化机制，也有一种可能，就是这个消息写到了rabbitmq中，但是还没来得及持久化到磁盘上，结果不巧，此时rabbitmq挂了，就会导致内存里的一点数据会丢失。

##### （3）消费端弄丢失了数据

这个时候得用rabbitmq提供的ack机制，简单来说，就是我们关闭rabbitmq自动ack，可以通过一个api来调用就行，然后每次我们自己代码里面确保处理完的时候，在程序里手动ack一次。这样的话，如果我们还没处理完就没有ack了。这个时候rabbitmq就会认为我们还没处理完，rabbitmq就会把这个消息分配给别的消费者去处理，消息是不会丢失的。

```java
在容器中设置
(消费者手动ACK)
AcknowledgeMode关于这个类 就是一个简单的枚举类：
3个状态 不确认 手动确认 自动确认

```



## 5、如何保证消息的顺序性？

拆分多个 Queue，每个 Queue一个 Consumer，就是多一些 Queue 而已，确实是麻烦点；这样也会造成吞吐量下降，可以在消费者内部采用多线程的方式取消费。

或者就一个 Queue 对应一个 Consumer，然后这个 Consumer 内部用内存队列做排队，然后分发给底层不同的 线程来处理。

## 6、大量消息在 MQ 里长时间积压，该如何解决？消息设置了过期时间，过期就丢了怎么办

一般这个时候，只能做临时紧急扩容了：

1. 先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉；
2. 新建一个 topic，临时建立好原先 10到20 倍的 queue 数量；（partition是原来的 10 倍）
3. 然后写一个临时分发消息的consumer程序，这个程序部署上去消费积压的消息，直接均匀轮询写入临时建好10倍数量的queue里面。
4. 紧接着征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的消息。
5. 这种做法相当于临时将queue资源和consumer资源扩大10倍，以正常速度的10倍来消费消息。
6. 等快速消费完了之后，恢复原来的部署架构，重新用原来的consumer机器来消费消息。

##### 消息设置了过期时间，过期就丢了怎么办

等过了高峰期以后开始写程序，将丢失的那批数据一点一点的查出来，然后重新灌入 MQ 里面去，把丢的数据给补回来。

## 7、四种交换机的类型

#### **direct**

这种类型的交换机的路由规则是根据一个routingKey的标识，交换机通过一个routingKey与队列绑定；

#### topic

　符号“#”表示匹配一个或多个词，符号“*”表示匹配一个词。

#### **fanout: **(广播模式)

广播模式，代表每个消费者都会收到消息，每一个收到的都是1，2，3，4，5，6

#### **header**s

 基于消息的头部数据匹配，header 交换器和 direct 交换器完全一致，但是性能却差很多，因此基本上不会用到该交换器

## 8、RabbitMQ五种工作模式

#### 1、简单队列

　一个生产者对应一个消费者，没有交换机。

#### 2、work 模式

　　一个生产者对应多个消费者，但是一条消息只能有一个消费者获得消息；（轮询分发）（公平分发：手动确认，效率高的消费者消费消息多）没有交换机。

#### 3、发布/订阅模式

一个消费者将消息首先发送到交换机，交换机绑定到多个队列，然后被监听该队列的消费者所接收并消费。

#### 4、路由模式（direct交换机）

生产者将消息发送到direct交换器，在绑定队列和交换器的时候有一个路由key，生产者发送的消息会指定一个路由key，那么消息只会发送到相应key相同的队列，接着监听该队列的消费者消费消息。

#### 5、主题模式（topic）

模糊匹配路由键；

　符号“#”表示匹配一个或多个词，符号“*”表示匹配一个词。

## 9、死信交换机/死信队列

在创建队列的时候 可以给这个队列附带一个交换机， 这个队列作废的消息就会被重新发到附带的交换机，然后让这个交换机重新路由这条消息；

只是对应的队列设置了对应的交换机是死信交换机， 对于交换机来讲， 他还是一个普通的交换机 

```java
@Beanpublic Queue queue() { 
    Map<String,Object> map = new HashMap<>(); 
    //设置消息的过期时间 单位毫秒 
    map.put("x-message-ttl",10000); 
    //设置附带的死信交换机 
    map.put("x-dead-letter-exchange","exchange.dlx"); 
    //指定重定向的路由建 消息作废之后可以决定需不需要更改他的路由建 如果需要 就在这里指定 
    map.put("x-dead-letter-routing-key","dead.order"); 
    return new Queue("testQueue", true,false,false,map); 
}
```

## 10、**RabbitMQ：镜像集群模式**

RabbitMQ 是基于主从做高可用性的，Rabbitmq有三种模式：单机模式、普通集群模式、镜像集群模式。单机模式一般在生产环境中很少用，普通集群模式只是提高了系统的吞吐量，让集群中多个节点来服务某个 Queue 的读写操作。那么真正实现 RabbitMQ 高可用的是镜像集群模式。

镜像集群模式跟普通集群模式不一样的是，创建的 Queue，无论元数据还是Queue 里的消息都会存在于多个实例上，然后每次你写消息到 Queue 的时候，都会自动和多个实例的 Queue 进行消息同步。这样设计，好处在于：任何一个机器宕机不影响其他机器的使用。

坏处在于：1. 性能开销太大：消息同步所有机器，导致网络带宽压力和消耗很重；

2. 扩展性差：如果某个 Queue 负载很重，即便加机器，新增的机器也包含了这个 Queue 的所有数据，并没有办法线性扩展你的 Queue。

## 11、RabbitMQ：搭建集群

具体想让rabbitmq实现集群， 我们首先需要改一下系统的hostname (因为rabbitmq集群节点名称是读取

hostname的)；

我们需要将各个节点的.erlang.cookie文件内容保持一致

内存节点：ram,写入内存。

磁盘节点：disc,写入磁盘。

RabbitMQ要求最少有一个磁盘节点。满足高可用的话，要最少两个磁盘节点。







# 微服务

## 1、spring cloud alibaba

### Nacos   

**注册中心和配置中心**

 1.**服务注册**：Nacos Client会通过发送 rest 请求的方式向Nacos Server注册自己的服务，提供自身的元数据，比如ip地址、端口等信息。 Nacos Server接收到注册请求后，就会把这些元数据信息存储在一个双层的内存Map中。 
  2.**服务心跳**：在服务注册后，Nacos Client会维护一个定时心跳来持续通知Nacos Server，说明服务一直处于可用状态，防止被剔除。默认 5s发送一次心跳。 
  3.**服务同步**：Nacos Server集群之间会互相同步服务实例，用来保证服务信息的一致性。       
  4.**服务发现**：服务消费者（Nacos Client）在调用服务提供者的服务时，会发送一个REST请求给Nacos Server，获取上面注册的服务清 单，并且缓存在Nacos Client本地，同时会在Nacos Client本地开启一个定时任务定时拉取服务端最新的注册表信息更新到本地缓存
  5.**服务健康检查**：Nacos Server会开启一个定时任务用来检查注册服务实例的健康情况，对于超过15s没有收到客户端心跳的实例会将它的健康(healthy) 属性置为false，如果某个实例超过30秒没有收到心跳，直接剔除该实例(被剔除的实例如果恢复发送 心跳则会重新注册)

### Robbin   

负载均衡

### Feign   

负载均衡，远程调用

### Sentinel 

 **以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。**

 比Hystrix功能更加丰富，可基于控制台进行实时监控与实时规则修改。

1、**限流**

流量控制有以下几个角度:

- 资源的调用关系，例如资源的调用链路，资源和资源之间的关系；
- 运行指标，例如 QPS、线程池、系统负载等；
- 控制的效果，例如直接限流、冷启动、排队等。

2、**熔断降级**

Sentinel 采用了与 Hystrix 不一样的方法：

- 通过并发线程数进行限制（Hystrix 采用线程池隔离，需要预先创建线程池）；
- 通过响应时间对资源进行降级。

3、**控制台**

Sentinel 控制台基于Spring Boot 开发，打包后可直接运行。它提供机器发现以及健康情况管理、监控（单机和集群），规则管理和推送的功能。

### Gateway 

高性能异步非阻塞网关 ， 统一入口

Gateway 网关三个关键名词：路由（Route）、断言（Predicate）、过滤器（Filter）。

路由：是指一个完整的网关地址映射与处理过程。一个完整的路由包含两部分配置：断言（Predicate）与过滤器（Filter）。前端应用发来的请求要被转发到哪个微服务上，是由断言决定的，而转发过程中请求、响应数据被网关如何加工处理是由过滤器决定的。
断言：指定了路由的规则条件；
过滤器：可以在请求发出的前后执行一些业务处理，如鉴权、限流、埋点等。



**执行流程**

2、请求首先会被HttpWebHandler(饿大普特儿)Adapter进行提取组装成网关上下文
3、然后网关的上下文会传递到DispatcherHandler，它负责将请求分发给 Route(普弱dei 凯特)Predicate HandlerMapping
4、RoutePredicateHandlerMapping负责路由查找，并根据路由断言判断路由是否可用
5、如果过断言成功，由FilteringWebHandler创建过滤器链并调用
6、请求会一次经过PreFilter–微服务–PostFilter的方法，最终返回响应

## 2、Seata 分布式事务

#### AT模式

AT 模式基于支持本地 ACID 事务的关系型数据库，是一种无侵入弱一致的2pc模式

#### TCC模式

TCC 模式不依赖于底层数据资源的事务支持

#### Saga模式

Saga模式是seata提供的长事务解决方案

#### XA模式 

XA模式是分布式强一致性的解决方案，但性能低而使用较少



### AT模式   

- **事务协调器 TC**

维护全局和分支事务的状态，指示全局提交或者回滚。

- **事务管理者 TM**

开启、提交或者回滚一个全局事务。

- **资源管理者 RM**

管理执行分支事务的那些资源，向TC注册分支事务、上报分支事务状态、控制分支事务的提交或者回滚。

####  AT 执行流程 

1、TM 请求 TC（事务协调器，一个独立运行的服务），说明自己要开启一个全局事务，TC 会生成一个全局事务ID（XID），并返回给 TM；

2、TM 得到 XID 后，开始调用微服务，XID 通过微服务的调用链传递到其他微服务；

3、RM 会收到 XID，知道自己的事务属于这个全局事务。 执行自己的业务逻辑，操作本地数据库。RM会把自己的事务注册到 TC，作为这个 XID 下面的一个**分支事务**，并且把自己的事务执行结果也告诉 TC。

4、在各个微服务都执行完成后，TC 可以知道 XID 下各个分支事务的执行结果，TM 也就知道了。

5、TM 如果发现各个微服务的本地事务都执行成功了，就请求 TC 对这个 XID 提交，否则回滚。

6、TC 收到请求后，向 XID 下的所有分支事务发起相应请求。

7、各个微服务收到 TC 的请求后，执行相应指令 提交或者回滚，并把执行结果上报 TC。



#### AT重要机制

**（1）全局事务的回滚是如何实现的呢？**

Seata 有一个重要的机制：**回滚日志**。

每个分支事务对应的数据库中都需要有一个回滚日志表 UNDO_LOG，在真正修改数据库记录之前，都会先记录修改前的记录值，以便之后回滚。

在收到回滚请求后，就会根据 UNDO_LOG 生成回滚操作的 SQL 语句来执行。

如果收到的是提交请求，就把 UNDO_LOG 中的相应记录删除掉。

**（2）RM 是怎么自动和 TC 交互的？**

是通过**监控拦截JDBC**实现的，例如监控到开启本地事务了，就会自动向 TC 注册、生成回滚日志、向 TC 汇报执行结果。

**（3）二阶段回滚失败怎么办？**

例如 TC 命令各个 RM 回滚的时候，有一个微服务挂掉了，那么所有正常的微服务也都不会执行回滚，当这个微服务重新正常运行后，TC 会重新执行全局回滚。

#### 关于AT读写的隔离：

写隔离：AT模式会基于全局锁保证写隔离，事务操作必须获取到全局锁才能执行commit或rollback，获取不到会重试直到超时，超时后会回滚本地事务，以此避免脏写；
读隔离：AT模式默认的读隔离级别为读未提交，出于性能考虑，一般的SELECT语句都不会阻塞，目前只对SELECT FOR UPDATE语句进行全局锁控制。





## spring cloud 

##### Eureka 

注册中心

##### Robbin 

负载均衡

##### Feign

负载均衡，远程调用

##### Hystrix

服务的隔离及断路器

##### Zull

网关

# 十一、数据库

## 1、MySQL 架构

MySQL 可以分为 Server 层和存储引擎两部分；

Server 层包括：连接器、查询缓存、分析器、优化器、执行器等；涵盖了 MySQL 的大多数核心服务功能，以及所有的内置函数（如：日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如：存储过程、触发器、视图等等。

存储引擎层负责：数据的存储和提取。不同的存储引擎共用一个 Server 层，也就是从连接器到执行器的部分。

## 2、一条SQL查询语句在Mysql中如何执行的？

先检查该语句**是否有权限**，如果没有权限，直接返回错误信息，如果有权限会先查询缓存；

如果没有缓存，分析器进行**词法分析**，提取 sql 语句中 select 等关键元素，然后判断 sql 语句是否有语法错误，比如关键词是否正确等等。

最后优化器确定执行方案进行权限校验，如果没有权限就直接返回错误信息，如果有权限就会**调用数据库引擎接口**，返回执行结果。

## 2、数据库三范式

1. 第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项；
2. 第二范式：要求实体的属性完全依赖于主关键字。完全依赖是指不能存在仅依赖主关键字一部分的属性；
3. 第三范式：任何非主属性不依赖于其它非主属性。

## 3、最左前缀原则

比如：三个字段是(name, age, sex)建立联合索引 的时候，B+ 树是按照从左到右的顺序来建立搜索树的，比如：当(小明, 22, 男)这样的数据来检索的时候，B+ 树会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex，最后得到检索的数据。但当 (22, 男) 这样没有 name 的数据来的时候，B+ 树就不知道第一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询。



## 4、如何建立索引

主键自动建立唯一索引

频繁作为查询条件的字段应该创建索引。经常增删改的表或者字段不需要创建索引，因为更新时MySQL

不仅要保存数据，也要保存索引。

查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。

重复度比较低的可以适合建立索引。

## 5、回表、覆盖

##### 尽量使用覆盖索引进行查询，避免回表带来的性能损耗

##### 回表

用任何主键索引之外的索引去查询数据的时候，他都要扫描自己的B+树，再扫描主键索引的B+树，多扫描一棵B+树的过程叫做回表。

##### 覆盖

就是 (select) 的字段 全部都是索引里边包含的字段，这样就不需要去回表了。



## 6、什么情况下索引会失效？即查询不走索引？

1、索引列参与表达式计算：

2、 函数运算：

3、%词语%–模糊查询：（xxx%这个才行）

## 8、常见的优化手段

#### 一、优化表结构

（1）尽量使用数字型字段

若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。

（2）尽可能的使用 varchar 代替 char

变长字段存储空间小，可以节省存储空间。

（3）当索引列大量重复数据时，可以把索引删除掉

比如有一列是性别，几乎只有男、女、未知，这样的索引是无效的

#### 二，优化查询

- 应尽量避免在 where 子句中使用!=或<>操作符
- 应尽量避免在 where 子句中使用 or 来连接条件
- SELECT语句务必指明字段名称：用SELECT * 会增加很多不必要的消耗
- 避免在 where 子句中对字段进行 null 值判断
- 只返回必要的行：使用 LIMIT 语句来限制返回的数据。

#### 三，索引优化

- 对作为查询条件和 order by的字段建立索引
- 避免建立过多的索引，多使用组合索引
- 遵从最左前缀原则

## 9、explain 各个字段的含义？

（1）id 列：是 select 语句的序号，Mysql将 select 查询分为简单查询和复杂查询。

（2）select_type列：表示对应行是是简单还是复杂的查询。

（3）table 列：表示 explain 的一行正在访问哪个表。

（4）type 列：表示关联类型或访问类型，就是 MySQL 决定如何查找表中的行。从最优到最差分别为：system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL

（5）**possible_keys** 列：显示查询可能使用哪些索引来查找。

（6）**key** 列：这一列显示 实际采用哪个索引。

（7）**key_len** 列：显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。

（8）ref 列：这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），func，NULL，字段名。

（9）rows 列：这一列是 mysql 估计要读取并检测的行数，注意这个不是结果集里的行数。

（10）Extra 列：显示额外信息。比如有 Using index、Using where、Using temporary等。

## 9、InnoDB 和 MyISAM 的比较？

1. 事务：MyISAM不支持事务，InnoDB支持事务；
2. 全文索引：MyISAM 支持全文索引，InnoDB 5.6 之前不支持全文索引；
3. 关于 count(*)：MyISAM会直接存储总行数，InnoDB 则不会，需要按行扫描。意思就是对于 select count(*) from table; 如果数据量大，MyISAM 会瞬间返回，而 InnoDB 则会一行行扫描；
4. 外键：MyISAM 不支持外键，InnoDB 支持外键；
5. 锁：MyISAM 只支持表锁，InnoDB 可以支持行锁。

## 10、水平切分和垂直切分的理解

- **水平切分**

水平切分是将同一个表中的记录拆分到多个结构相同的表中。当一个表的数据不断增多时，水平切分是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。

- **垂直切分**

垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。例如：将原来的电商数据库垂直切分成商品数据库、用户数据库等。

## 11、读写分离的理解

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

**读写分离能提高性能的原因在于：**

1. 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
2. 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
3. 增加冗余，提高可用性。

## 12、说一下 MySQL 的行锁和表锁？

MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。

表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。

行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。

## 13、MVCC 熟悉吗，知道它的底层原理？

MVCC，即多版本并发控制技术。

MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。

## 14、主从复制分了五个步骤进行

- 步骤一：主库的更新事件(update、insert、delete)被写到binlog
- 步骤二：从库发起连接，连接到主库。
- 步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库。
- 步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log
- 步骤五：还会创建一个SQL线程，从relay log里面读取内容，将更新内容写入到从机(slave)的db

## 15、分库分表可能遇到的问题

- 事务问题：需要用分布式事务啦
- 跨节点Join的问题：解决这一问题可以分两次查询实现
- 数据迁移，容量规划，扩容等问题
- ID问题：数据库被切分后，不能再依赖数据库自身的主键生成机制啦，最简单可以考虑UUID
- 跨分片的排序分页问题

## 16、**主从同步延迟的原因**

一个服务器开放Ｎ个链接给客户端来连接的，这样有会有大并发的更新操作, 但是从服务器的里面读取binlog的线程仅有一个，当某个SQL在从服务器上执行的时间稍长 或者由于某个SQL要进行锁表就会导致，主服务器的SQL大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。

## 17、**主从同步延迟的解决办法**

- 主服务器要负责更新操作，对安全性的要求比从服务器要高，所以有些设置参数可以修改，比如sync_binlog=1之类的设置等。
- 选择更好的硬件设备作为slave。
- 增加从服务器，这个目的还是分散读的压力，从而降低服务器负载。

# 设计模式

## 1、单例模式

#### 懒汉式

线程不安全：最基础的实现方式，线程上下文单例，不需要共享给所有线程，也不需要加synchronize之类的锁，以提高性能

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```java
package com.yjc.singleton;
/**
 * 单例之懒汉式
 * */
public class LazySingleton {
    //构造私有化
    private LazySingleton()
    {

    }
    //类加载的时候不进行初始化
    private  static LazySingleton lazySingleton=null;


    public  static LazySingleton getLazySingleton(){
        //当调用者需要获取一个对象的时候,首先判断当前的对象是否已经进行过实例化了,
        if (lazySingleton!=null){
            //当多个线程同时进入此处的时候,就无法保证是单例的了,因此这种方式是线程非安全的
            lazySingleton=new LazySingleton();
        }
        return lazySingleton;
    }

}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

#### 饿汉式

类加载的时候进行初始化,典型的以空间换时间,线程是安全的,无法做到延迟加载

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```java
package com.yjc.singleton;
/**
 * 单例之饿汉式
 * */
public class HungrySingleton {
    //构造私有化
    private HungrySingleton()
    {

    }
    private  static HungrySingleton hungrySingleton=new HungrySingleton(); //类加载的时候直接实例化

    public  static  HungrySingleton getHungrySingleton()
    {
        return hungrySingleton;
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

#### 双重锁懒汉模式(Double Check Lock)

双重校验是懒汉式的升级版,通过加锁实现了线程安全,并同时具备延迟加载的机制

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```java
package com.yjc.singleton;
/**
 * 单例之双重校验(懒汉式的线程安全版)
 * */
public class DoubleCheckSingleton {
    //构造方法私有化
    private  DoubleCheckSingleton()
    {

    }
    //volatile用于保证内存可见性,所有线程都能看到共享内存的最新状态
    private  static volatile DoubleCheckSingleton doubleCheckSingleton=null;
　　　　
    public  static  DoubleCheckSingleton getDoubleCheckSingleton(){
        if (doubleCheckSingleton!=null){
            //synchronized保证同时只能有一个线程进行实例化对象
            synchronized (DoubleCheckSingleton.class){
                if (doubleCheckSingleton!=null){
                    doubleCheckSingleton=new DoubleCheckSingleton();
                }
            }
        }
            return doubleCheckSingleton;
    }

}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

第一次判断doubleCheckSingleton== null为了避免非必要加锁，当第一次加载时才对实例进行加锁再实例化。这样既可以节约内存空间，又可以保证线程安全

在JDK1.6及之后volatile可以解决DCL失效问题,volatile确保单例对象每次均在主内存中读取，这样虽然会牺牲一点效率，但也没有太多影响

#### 静态内部类

静态内部类的优点是:在外部类被加载的时候,内部类并不会被立即加载,内部类没有被加载,单例对象也就没有进行实例化,从而也不会占内存。只有在第一次访问内部类中的属性时才会加载内部类并将内部类中的对象进行实例化。这种方法不仅可以确保线程的安全和对象唯一,也延迟了单例对象的实例化

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```java
package com.yjc.singleton;
/**
 * 单例之静态内部类
 * */
public class StaticInnerClassSingleton {

    //构造私有化
    private  StaticInnerClassSingleton()
    {

    }
    //静态内部类,外部类被加载时,内部类不会被加载
    private  static  class StaticInnerClass
    {
        // 静态初始化器，由JVM来保证线程安全
        private  static StaticInnerClassSingleton staticInnerClassSingleton=new StaticInnerClassSingleton();
    }

    public  static  StaticInnerClassSingleton getStaticInnerClassSingleton()
    {
        //此时开始加载内部类,并将对象进行实例化
        return StaticInnerClass.staticInnerClassSingleton;
    }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

#### 枚举

枚举的特性:枚举实例不仅是线程安全的,而且在任何情况下它都是一个单例,枚举的属性都是静态常量。

枚举单例可以自己处理序列化:传统的单例模式的另外一个问题是一旦你实现了serializable接口，他们就不再是单例的了。

因为readObject()方法总是返回一个 新的实例对象，就像java中的构造器一样。你可以使用readResolve()方法来避免这种情况

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```java
package com.yjc.singleton;

public class Singleton {
        //私有化构造
        private Singleton() {
        }

        public static Singleton getInstance() {
            
            return SingletonEnum.INSTANCE.getInstance();
        }

        private enum SingletonEnum {
            INSTANCE;

            private Singleton singleton;

            // JVM保证这个方法绝对只调用一次
            SingletonEnum() {
                singleton = new Singleton();
            }

            public Singleton getInstance() {
                return singleton;
            }
        }
}
```

## 2、工厂模式

就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建

**1、简单工厂**：允许接口创建对象，但不会暴露对象的创建逻辑。
**2、工厂方法**：允许接口创建对象，但使用哪个类来创建对象，则是交由子类决定的。
**3、抽象工厂** ：抽象工厂是一个能够创建一系列相关的对象而无需指定/公开其具体类的接口。该模式能够提供其他工厂的对象，在其内部创建其他对象。

## 3、代理模式

如果已有的方法在使用的时候需要对原有的方法进行改进，使用代理模式，可以将功能划分的更加清晰，有助于后期维护！

静态代理

JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口 。JDK 动态代理的核心是 InvocationHandler 接口和 Proxy 类 。

CGLIB 是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意， CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final ，那么它是无法使用 CGLIB 做动态代理的 。



## 4、适配器模式

配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。

## 5、装饰器模式

1、需要扩展一个类的功能。

2、动态的为一个对象增加功能，而且还能动态撤销。

## 6、桥接模式

桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。



**二、设计模式的六大原则**

**1、[开闭原则](http://www.so.com/s?q=开闭原则&ie=utf-8&src=se_lighten)（Open Close Principle）**

开闭原则就是说**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和[抽象类](http://www.so.com/s?q=抽象类&ie=utf-8&src=se_lighten)，后面的具体设计中我们会提到这点。

**2、里氏代换原则（Liskov Substitution Principle）**

里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科

**3、[依赖倒转](http://www.so.com/s?q=依赖倒转&ie=utf-8&src=se_lighten)原则（Dependence Inversion Principle）**

这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。

**4、接口隔离原则（Interface Segregation Principle）**

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的[耦合度](http://www.so.com/s?q=耦合度&ie=utf-8&src=se_lighten)的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。

**5、迪米特法则（最少知道原则）（Demeter Principle）**

为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

**6、合成复用原则（Composite Reuse Principle）**

原则是尽量使用合成/聚合的方式，而不是使用继承。





















