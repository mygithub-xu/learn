# mysql

#### mysql基本组成

server层：

- 连接池：每次建立与断开连接需要消耗时间。连接池将这些连接缓存下来，方便下次直接使用

- 管理工具与服务：系统的管理合控制工具

- sql接口：接受sql命令，返回结果

- 解析器：解析sql命令

- 优化器：优化sql语句

- 缓存器：缓存命中的查询结构，下次直接返回

  **tip：在8.0开始不再使用缓存。因为基准测试发现，缓存造成的问题大于解决的问题**

存储引擎（下面细讲）：

- 数据的存储和提取（不同的存储引擎使用同一个server）

#### 存储引擎

mysql区别于其他数据库的一个最重要的一点是可以自定义存储引擎（插件式），比如innoDB.

innoDB：mysql5.7后默认事务性引擎。支持事务（事务）

myISAm：5.1之前版本默认存储引擎。MyISAM提供了大量的特性，包括全文索引、压缩、空间函数（GIS）等，但MyISAM不支持事务和行级锁，而且崩溃后无法安全恢复。（读多写少）



区别：        

- 主外键：myISAm：不支持             innoDB：支持

- 事务：myISAm：不支持             innoDB：支持

- 行表锁：myISAm：支持表锁             innoDB：支持行表锁

- 关注点：myISAm：性能             innoDB：事务

- 索引：myISAm：非聚簇索引，索引与数据分开存储    innoDB：聚簇索引，索引和数据存储在一起。

  [^聚簇索引]: 必须存在一个主键作为索引，且数据文件和索引是绑在一起的。插入时按照主键顺序排列。查询时，辅助索引需要两次查询（回表）

使用区别：

- myISAm：以读写插入为主的应用程序，比如博客。
- innodb：以更新比较频繁，且需要保证数据完整性。

#### 日志文件

- 错误日志（error log）：mysql的启动运行关闭
- 慢查询日志（slow query log）：sql慢的查询，默认off
- 查询日志（query log）：记录了所有对MySQL数据库请求的信息，无论这些请求是否得到了正确的执行。
- 归档日志（bin log）：记录所有ddl，dml语句（除了select语句）
- 重做日志（redo log）：

#### 范式

第一范式：字段属性不可分割（如：字段 name_age 可分为name和age）

第二范式：字段属性完全依赖于主关键字

第三范式：表中每个字段都与主键直接有关，而不是间接

#### 索引

数据结构角度分为：b+树索引，哈希索引，fullText索引和R-TTree索引


##### hash索引和b+tree索引的区别

hash索引无法实现范围查找，排序，模糊查询等功能

使用场景：

若字段会出现大量重复数据、检索需要排序、分组、范围查询、模糊查询等操作，hash无法满足要求，建议使用B+Tree.

在离散型高，数据基数大，且等值查询得时候，Hash索引有优势。

##### 优化

[https://blog.csdn.net/qq_40068304/article/details/121520902](https://blog.csdn.net/qq_40068304/article/details/121520902)

1.避免使用 select *

2.小表驱动大表

3.大量数据批量操作（勿一条条插入）

4.若不要求全部数据多使用limit

5.join的表尽量控制在2-3个表

6.避免索引失效

##### 是否可以建立索引

将经常需要查询，排序，分组，联合操作的字段建立索引。字段尽量设置不为null。索引列上不进行计算。

##### 索引失效场景

1.  不满足最左前缀原则

2.  使用select *

3.  索引列上使用的函数

4.  索引字段使用is null

5.  like查询左边有%

6.  字符类型未加引号



#### 事务

##### 事务产生的原因：

- 脏读：当A对数据做了修改并未提交时，B读取到了修改后的数据。
- 可重复读：在A中多次读取数据，多次读取的数据不一致。
- 幻读：与可重复读相似，在A中多次读取数据，多次读取的数据量不一致。（强调个数）

##### 隔离级别：

所以，引入了隔离级别去解决

- **Read Uncommited**（简称RU 读未提交）：可以读取未提交数据（无法解决上述问题）

- **Read commited**（简称RC 读已提交）：只能读取已提交数据（解决脏读）

- **Repeatable（rui pi te bo） read**（简称RR  可重复读）：可以读取未提交数据（解决脏读和可重复读）

- [^]: 在innoDB中默认使用RR，并且使用了mvcc机制去解决幻读

- **Serializable**（串行化）：读写均加锁



#### mvcc的实现

1. 先在每条数据后创建三个隐藏字段（DB_ROW_ID：行id，DB_TRX_ID：事务id，DB_ROLL_PTR：回滚指针）

2. 在新增，删除，修改的时候，创建记录并将回滚指针指向该事务的前一数据然后保存在undo log，形成版本链。（新的事务只能查询到）

3. 读的时候，创建readview（trx_ids：活跃的事务ids。up_limit_id：最小事务id。low_limit_id：最大事务id。creator_trx_id：创建该事务的id）。然后第一次select会根据版本链（先找出ids，版本链中事务id存在ids内的数据均不能使用）找到视图的数据。

   第二次select就会直接根据视图规则判断是否可以使用该视图（trx_id<up_limit_id：可以。up_limit_id<trx_id<low_limit_id：在trx_ids内不可以，在外可以。trx_id>low_limit_id：可以）

4. 当该事务要回滚时，会回滚



图解：



##### RR和RC的实现区别

均由undo log实现，主要是版本链及readview。。

rr：在第一次select生成readview，接下来的select均会沿用，这个readview（）

rc：在每一次的select都生成readview。（如此，前一个事务提交后，这次得select就会得到事务提交后的数据，所以还是会出现重复读和幻读。但在每一次更新readview的时候，自动）







##### 解决数据的读写一致性

LBCC：简单来说就是进行单线程访问。（类似于redis）。但是在并发大的情况下效率很低

MVCC：直接进行备份，按照版本号进行查询。实现方式是使用undo log进行实现的

[^mvcc查询规则]: 只能查找创建时间小于等于和删除时间大于（使用创建版本字典，和删除版本字段决定）当前事务id的数据。
[^undo log实现隔离级别]: 根据版本链和readview（读视图）去完成mvcc的



#### 一条查询sql的执行记录

- 查询语句：缓存是否命中->解析查询->优化->执行查询